{"ts":1377222060635,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"<?php\n/**\n * Methods for displaying presentation data in the view.\n *\n * PHP 5\n *\n * CakePHP(tm) : Rapid Development Framework (http://cakephp.org)\n * Copyright (c) Cake Software Foundation, Inc. (http://cakefoundation.org)\n *\n * Licensed under The MIT License\n * For full copyright and license information, please see the LICENSE.txt\n * Redistributions of files must retain the above copyright notice.\n *\n * @copyright     Copyright (c) Cake Software Foundation, Inc. (http://cakefoundation.org)\n * @link          http://cakephp.org CakePHP(tm) Project\n * @package       Cake.View\n * @since         CakePHP(tm) v 0.10.0.1076\n * @license       http://www.opensource.org/licenses/mit-license.php MIT License\n */\n\nApp::uses('HelperCollection', 'View');\nApp::uses('AppHelper', 'View/Helper');\nApp::uses('Router', 'Routing');\nApp::uses('ViewBlock', 'View');\nApp::uses('CakeEvent', 'Event');\nApp::uses('CakeEventManager', 'Event');\nApp::uses('CakeResponse', 'Network');\n\n/**\n * View, the V in the MVC triad. View interacts with Helpers and view variables passed\n * in from the controller to render the results of the controller action. Often this is HTML,\n * but can also take the form of JSON, XML, PDF's or streaming files.\n *\n * CakePHP uses a two-step-view pattern. This means that the view content is rendered first,\n * and then inserted into the selected layout. This also means you can pass data from the view to the\n * layout using `$this->set()`\n *\n * Since 2.1, the base View class also includes support for themes by default. Theme views are regular\n * view files that can provide unique HTML and static assets. If theme views are not found for the\n * current view the default app view files will be used. You can set `$this->theme = 'mytheme'`\n * in your Controller to use the Themes.\n *\n * Example of theme path with `$this->theme = 'SuperHot';` Would be `app/View/Themed/SuperHot/Posts`\n *\n * @package       Cake.View\n * @property      CacheHelper $Cache\n * @property      FormHelper $Form\n * @property      HtmlHelper $Html\n * @property      JsHelper $Js\n * @property      NumberHelper $Number\n * @property      PaginatorHelper $Paginator\n * @property      RssHelper $Rss\n * @property      SessionHelper $Session\n * @property      TextHelper $Text\n * @property      TimeHelper $Time\n * @property      ViewBlock $Blocks\n */\nclass View extends Object {\n\n/**\n * Helpers collection\n *\n * @var HelperCollection\n */\n\tpublic $Helpers;\n\n/**\n * ViewBlock instance.\n *\n * @var ViewBlock\n */\n\tpublic $Blocks;\n\n/**\n * Name of the plugin.\n *\n * @link http://manual.cakephp.org/chapter/plugins\n * @var string\n */\n\tpublic $plugin = null;\n\n/**\n * Name of the controller.\n *\n * @var string Name of controller\n */\n\tpublic $name = null;\n\n/**\n * Current passed params\n *\n * @var mixed\n */\n\tpublic $passedArgs = array();\n\n/**\n * An array of names of built-in helpers to include.\n *\n * @var mixed A single name as a string or a list of names as an array.\n */\n\tpublic $helpers = array('Html');\n\n/**\n * Path to View.\n *\n * @var string Path to View\n */\n\tpublic $viewPath = null;\n\n/**\n * Variables for the view\n *\n * @var array\n */\n\tpublic $viewVars = array();\n\n/**\n * Name of view to use with this View.\n *\n * @var string\n */\n\tpublic $view = null;\n\n/**\n * Name of layout to use with this View.\n *\n * @var string\n */\n\tpublic $layout = 'default';\n\n/**\n * Path to Layout.\n *\n * @var string Path to Layout\n */\n\tpublic $layoutPath = null;\n\n/**\n * Turns on or off Cake's conventional mode of applying layout files. On by default.\n * Setting to off means that layouts will not be automatically applied to rendered views.\n *\n * @var boolean\n */\n\tpublic $autoLayout = true;\n\n/**\n * File extension. Defaults to Cake's template \".ctp\".\n *\n * @var string\n */\n\tpublic $ext = '.ctp';\n\n/**\n * Sub-directory for this view file. This is often used for extension based routing.\n * Eg. With an `xml` extension, $subDir would be `xml/`\n *\n * @var string\n */\n\tpublic $subDir = null;\n\n/**\n * Theme name.\n *\n * @var string\n */\n\tpublic $theme = null;\n\n/**\n * Used to define methods a controller that will be cached.\n *\n * @see Controller::$cacheAction\n * @var mixed\n */\n\tpublic $cacheAction = false;\n\n/**\n * Holds current errors for the model validation.\n *\n * @var array\n */\n\tpublic $validationErrors = array();\n\n/**\n * True when the view has been rendered.\n *\n * @var boolean\n */\n\tpublic $hasRendered = false;\n\n/**\n * List of generated DOM UUIDs.\n *\n * @var array\n */\n\tpublic $uuids = array();\n\n/**\n * An instance of a CakeRequest object that contains information about the current request.\n * This object contains all the information about a request and several methods for reading\n * additional information about the request.\n *\n * @var CakeRequest\n */\n\tpublic $request;\n\n/**\n * Reference to the Response object\n *\n * @var CakeResponse\n */\n\tpublic $response;\n\n/**\n * The Cache configuration View will use to store cached elements. Changing this will change\n * the default configuration elements are stored under. You can also choose a cache config\n * per element.\n *\n * @var string\n * @see View::element()\n */\n\tpublic $elementCache = 'default';\n\n/**\n * Element cache settings\n *\n * @var array\n * @see View::_elementCache();\n * @see View::_renderElement\n */\n\tpublic $elementCacheSettings = array();\n\n/**\n * List of variables to collect from the associated controller.\n *\n * @var array\n */\n\tprotected $_passedVars = array(\n\t\t'viewVars', 'autoLayout', 'ext', 'helpers', 'view', 'layout', 'name', 'theme',\n\t\t'layoutPath', 'viewPath', 'request', 'plugin', 'passedArgs', 'cacheAction'\n\t);\n\n/**\n * Scripts (and/or other <head /> tags) for the layout.\n *\n * @var array\n */\n\tprotected $_scripts = array();\n\n/**\n * Holds an array of paths.\n *\n * @var array\n */\n\tprotected $_paths = array();\n\n/**\n * Indicate that helpers have been loaded.\n *\n * @var boolean\n */\n\tprotected $_helpersLoaded = false;\n\n/**\n * The names of views and their parents used with View::extend();\n *\n * @var array\n */\n\tprotected $_parents = array();\n\n/**\n * The currently rendering view file. Used for resolving parent files.\n *\n * @var string\n */\n\tprotected $_current = null;\n\n/**\n * Currently rendering an element. Used for finding parent fragments\n * for elements.\n *\n * @var string\n */\n\tprotected $_currentType = '';\n\n/**\n * Content stack, used for nested templates that all use View::extend();\n *\n * @var array\n */\n\tprotected $_stack = array();\n\n/**\n * Instance of the CakeEventManager this View object is using\n * to dispatch inner events. Usually the manager is shared with\n * the controller, so it it possible to register view events in\n * the controller layer.\n *\n * @var CakeEventManager\n */\n\tprotected $_eventManager = null;\n\n/**\n * Whether the event manager was already configured for this object\n *\n * @var boolean\n */\n\tprotected $_eventManagerConfigured = false;\n\n/**\n * Constant for view file type 'view'\n */\n\tconst TYPE_VIEW = 'view';\n\n/**\n * Constant for view file type 'element'\n */\n\tconst TYPE_ELEMENT = 'element';\n\n/**\n * Constant for view file type 'layout'\n */\n\tconst TYPE_LAYOUT = 'layout';\n\n/**\n * Constructor\n *\n * @param Controller $controller A controller object to pull View::_passedVars from.\n */\n\tpublic function __construct(Controller $controller = null) {\n\t\tif (is_object($controller)) {\n\t\t\t$count = count($this->_passedVars);\n\t\t\tfor ($j = 0; $j < $count; $j++) {\n\t\t\t\t$var = $this->_passedVars[$j];\n\t\t\t\t$this->{$var} = $controller->{$var};\n\t\t\t}\n\t\t\t$this->_eventManager = $controller->getEventManager();\n\t\t}\n\t\tif (empty($this->request) && !($this->request = Router::getRequest(true))) {\n\t\t\t$this->request = new CakeRequest(null, false);\n\t\t\t$this->request->base = '';\n\t\t\t$this->request->here = $this->request->webroot = '/';\n\t\t}\n\t\tif (is_object($controller) && isset($controller->response)) {\n\t\t\t$this->response = $controller->response;\n\t\t} else {\n\t\t\t$this->response = new CakeResponse();\n\t\t}\n\t\t$this->Helpers = new HelperCollection($this);\n\t\t$this->Blocks = new ViewBlock();\n\t\tparent::__construct();\n\t}\n\n/**\n * Returns the CakeEventManager manager instance that is handling any callbacks.\n * You can use this instance to register any new listeners or callbacks to the\n * controller events, or create your own events and trigger them at will.\n *\n * @return CakeEventManager\n */\n\tpublic function getEventManager() {\n\t\tif (empty($this->_eventManager)) {\n\t\t\t$this->_eventManager = new CakeEventManager();\n\t\t}\n\t\tif (!$this->_eventManagerConfigured) {\n\t\t\t$this->_eventManager->attach($this->Helpers);\n\t\t\t$this->_eventManagerConfigured = true;\n\t\t}\n\t\treturn $this->_eventManager;\n\t}\n\n/**\n * Renders a piece of PHP with provided parameters and returns HTML, XML, or any other string.\n *\n * This realizes the concept of Elements, (or \"partial layouts\") and the $params array is used to send\n * data to be used in the element. Elements can be cached improving performance by using the `cache` option.\n *\n * @param string $name Name of template file in the/app/View/Elements/ folder,\n *   or `MyPlugin.template` to use the template element from MyPlugin. If the element\n *   is not found in the plugin, the normal view path cascade will be searched.\n * @param array $data Array of data to be made available to the rendered view (i.e. the Element)\n * @param array $options Array of options. Possible keys are:\n * - `cache` - Can either be `true`, to enable caching using the config in View::$elementCache. Or an array\n *   If an array, the following keys can be used:\n *   - `config` - Used to store the cached element in a custom cache configuration.\n *   - `key` - Used to define the key used in the Cache::write(). It will be prefixed with `element_`\n * - `plugin` - Load an element from a specific plugin. This option is deprecated, see below.\n * - `callbacks` - Set to true to fire beforeRender and afterRender helper callbacks for this element.\n *   Defaults to false.\n * - `ignoreMissing` - Used to allow missing elements. Set to true to not trigger notices.\n * @return string Rendered Element\n * @deprecated The `$options['plugin']` is deprecated and will be removed in CakePHP 3.0. Use\n *   `Plugin.element_name` instead.\n */\n\tpublic function element($name, $data = array(), $options = array()) {\n\t\t$file = $plugin = null;\n\n\t\tif (isset($options['plugin'])) {\n\t\t\t$name = Inflector::camelize($options['plugin']) . '.' . $name;\n\t\t}\n\n\t\tif (!isset($options['callbacks'])) {\n\t\t\t$options['callbacks'] = false;\n\t\t}\n\n\t\tif (isset($options['cache'])) {\n\t\t\t$contents = $this->_elementCache($name, $data, $options);\n\t\t\tif ($contents !== false) {\n\t\t\t\treturn $contents;\n\t\t\t}\n\t\t}\n\n\t\t$file = $this->_getElementFilename($name);\n\t\tif ($file) {\n\t\t\treturn $this->_renderElement($file, $data, $options);\n\t\t}\n\n\t\tif (empty($options['ignoreMissing'])) {\n\t\t\tlist ($plugin, $name) = pluginSplit($name, true);\n\t\t\t$name = str_replace('/', DS, $name);\n\t\t\t$file = $plugin . 'Elements' . DS . $name . $this->ext;\n\t\t\ttrigger_error(__d('cake_dev', 'Element Not Found: %s', $file), E_USER_NOTICE);\n\t\t}\n\t}\n\n/**\n * Checks if an element exists\n *\n * @param string $name Name of template file in the /app/View/Elements/ folder,\n *   or `MyPlugin.template` to check the template element from MyPlugin. If the element\n *   is not found in the plugin, the normal view path cascade will be searched.\n * @return boolean Success\n */\n\tpublic function elementExists($name) {\n\t\treturn (bool)$this->_getElementFilename($name);\n\t}\n\n/**\n * Renders view for given view file and layout.\n *\n * Render triggers helper callbacks, which are fired before and after the view are rendered,\n * as well as before and after the layout. The helper callbacks are called:\n *\n * - `beforeRender`\n * - `afterRender`\n * - `beforeLayout`\n * - `afterLayout`\n *\n * If View::$autoRender is false and no `$layout` is provided, the view will be returned bare.\n *\n * View and layout names can point to plugin views/layouts. Using the `Plugin.view` syntax\n * a plugin view/layout can be used instead of the app ones. If the chosen plugin is not found\n * the view will be located along the regular view path cascade.\n *\n * @param string $view Name of view file to use\n * @param string $layout Layout to use.\n * @return string Rendered Element\n * @throws CakeException if there is an error in the view.\n */\n\tpublic function render($view = null, $layout = null) {\n\t\tif ($this->hasRendered) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!$this->_helpersLoaded) {\n\t\t\t$this->loadHelpers();\n\t\t}\n\t\t$this->Blocks->set('content', '');\n\n\t\tif ($view !== false && $viewFileName = $this->_getViewFileName($view)) {\n\t\t\t$this->_currentType = self::TYPE_VIEW;\n\t\t\t$this->getEventManager()->dispatch(new CakeEvent('View.beforeRender', $this, array($viewFileName)));\n\t\t\t$this->Blocks->set('content', $this->_render($viewFileName));\n\t\t\t$this->getEventManager()->dispatch(new CakeEvent('View.afterRender', $this, array($viewFileName)));\n\t\t}\n\n\t\tif ($layout === null) {\n\t\t\t$layout = $this->layout;\n\t\t}\n\t\tif ($layout && $this->autoLayout) {\n\t\t\t$this->Blocks->set('content', $this->renderLayout('', $layout));\n\t\t}\n\t\t$this->hasRendered = true;\n\t\treturn $this->Blocks->get('content');\n\t}\n\n/**\n * Renders a layout. Returns output from _render(). Returns false on error.\n * Several variables are created for use in layout.\n *\n * - `title_for_layout` - A backwards compatible place holder, you should set this value if you want more control.\n * - `content_for_layout` - contains rendered view file\n * - `scripts_for_layout` - Contains content added with addScript() as well as any content in\n *   the 'meta', 'css', and 'script' blocks. They are appended in that order.\n *\n * Deprecated features:\n *\n * - `$scripts_for_layout` is deprecated and will be removed in CakePHP 3.0.\n *   Use the block features instead. `meta`, `css` and `script` will be populated\n *   by the matching methods on HtmlHelper.\n * - `$title_for_layout` is deprecated and will be removed in CakePHP 3.0\n * - `$content_for_layout` is deprecated and will be removed in CakePHP 3.0.\n *   Use the `content` block instead.\n *\n * @param string $content Content to render in a view, wrapped by the surrounding layout.\n * @param string $layout Layout name\n * @return mixed Rendered output, or false on error\n * @throws CakeException if there is an error in the view.\n */\n\tpublic function renderLayout($content, $layout = null) {\n\t\t$layoutFileName = $this->_getLayoutFileName($layout);\n\t\tif (empty($layoutFileName)) {\n\t\t\treturn $this->Blocks->get('content');\n\t\t}\n\n\t\tif (!$this->_helpersLoaded) {\n\t\t\t$this->loadHelpers();\n\t\t}\n\t\tif (empty($content)) {\n\t\t\t$content = $this->Blocks->get('content');\n\t\t}\n\t\t$this->getEventManager()->dispatch(new CakeEvent('View.beforeLayout', $this, array($layoutFileName)));\n\n\t\t$scripts = implode(\"\\n\\t\", $this->_scripts);\n\t\t$scripts .= $this->Blocks->get('meta') . $this->Blocks->get('css') . $this->Blocks->get('script');\n\n\t\t$this->viewVars = array_merge($this->viewVars, array(\n\t\t\t'content_for_layout' => $content,\n\t\t\t'scripts_for_layout' => $scripts,\n\t\t));\n\n\t\tif (!isset($this->viewVars['title_for_layout'])) {\n\t\t\t$this->viewVars['title_for_layout'] = Inflector::humanize($this->viewPath);\n\t\t}\n\n\t\t$this->_currentType = self::TYPE_LAYOUT;\n\t\t$this->Blocks->set('content', $this->_render($layoutFileName));\n\n\t\t$this->getEventManager()->dispatch(new CakeEvent('View.afterLayout', $this, array($layoutFileName)));\n\t\treturn $this->Blocks->get('content');\n\t}\n\n/**\n * Render cached view. Works in concert with CacheHelper and Dispatcher to\n * render cached view files.\n *\n * @param string $filename the cache file to include\n * @param string $timeStart the page render start time\n * @return boolean Success of rendering the cached file.\n */\n\tpublic function renderCache($filename, $timeStart) {\n\t\t$response = $this->response;\n\t\tob_start();\n\t\tinclude ($filename);\n\n\t\t$type = $response->mapType($response->type());\n\t\tif (Configure::read('debug') > 0 && $type === 'html') {\n\t\t\techo \"<!-- Cached Render Time: \" . round(microtime(true) - $timeStart, 4) . \"s -->\";\n\t\t}\n\t\t$out = ob_get_clean();\n\n\t\tif (preg_match('/^<!--cachetime:(\\\\d+)-->/', $out, $match)) {\n\t\t\tif (time() >= $match['1']) {\n\t\t\t\t//@codingStandardsIgnoreStart\n\t\t\t\t@unlink($filename);\n\t\t\t\t//@codingStandardsIgnoreEnd\n\t\t\t\tunset($out);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn substr($out, strlen($match[0]));\n\t\t}\n\t}\n\n/**\n * Returns a list of variables available in the current View context\n *\n * @return array Array of the set view variable names.\n */\n\tpublic function getVars() {\n\t\treturn array_keys($this->viewVars);\n\t}\n\n/**\n * Returns the contents of the given View variable(s)\n *\n * @param string $var The view var you want the contents of.\n * @return mixed The content of the named var if its set, otherwise null.\n * @deprecated Will be removed in 3.0. Use View::get() instead.\n */\n\tpublic function getVar($var) {\n\t\treturn $this->get($var);\n\t}\n\n/**\n * Returns the contents of the given View variable or a block.\n * Blocks are checked before view variables.\n *\n * @param string $var The view var you want the contents of.\n * @return mixed The content of the named var if its set, otherwise null.\n */\n\tpublic function get($var) {\n\t\tif (!isset($this->viewVars[$var])) {\n\t\t\treturn null;\n\t\t}\n\t\treturn $this->viewVars[$var];\n\t}\n\n/**\n * Get the names of all the existing blocks.\n *\n * @return array An array containing the blocks.\n * @see ViewBlock::keys()\n */\n\tpublic function blocks() {\n\t\treturn $this->Blocks->keys();\n\t}\n\n/**\n * Start capturing output for a 'block'\n *\n * @param string $name The name of the block to capture for.\n * @return void\n * @see ViewBlock::start()\n */\n\tpublic function start($name) {\n\t\treturn $this->Blocks->start($name);\n\t}\n\n/**\n * Start capturing output for a 'block' if it has no content\n *\n * @param string $name The name of the block to capture for.\n * @return void\n * @see ViewBlock::startIfEmpty()\n */\n\tpublic function startIfEmpty($name) {\n\t\treturn $this->Blocks->startIfEmpty($name);\n\t}\n\n/**\n * Append to an existing or new block. Appending to a new\n * block will create the block.\n *\n * @param string $name Name of the block\n * @param string $value The content for the block.\n * @return void\n * @throws CakeException when you use non-string values.\n * @see ViewBlock::concat()\n */\n\tpublic function append($name, $value = null) {\n\t\treturn $this->Blocks->concat($name, $value);\n\t}\n\n/**\n * Prepend to an existing or new block. Prepending to a new\n * block will create the block.\n *\n * @param string $name Name of the block\n * @param string $value The content for the block.\n * @return void\n * @throws CakeException when you use non-string values.\n * @see ViewBlock::concat()\n */\n\tpublic function prepend($name, $value = null) {\n\t\treturn $this->Blocks->concat($name, $value, ViewBlock::PREPEND);\n\t}\n\n/**\n * Set the content for a block. This will overwrite any\n * existing content.\n *\n * @param string $name Name of the block\n * @param string $value The content for the block.\n * @return void\n * @throws CakeException when you use non-string values.\n * @see ViewBlock::set()\n */\n\tpublic function assign($name, $value) {\n\t\treturn $this->Blocks->set($name, $value);\n\t}\n\n/**\n * Fetch the content for a block. If a block is\n * empty or undefined '' will be returned.\n *\n * @param string $name Name of the block\n * @param string $default Default text\n * @return string $default The block content or $default if the block does not exist.\n * @see ViewBlock::get()\n */\n\tpublic function fetch($name, $default = '') {\n\t\treturn $this->Blocks->get($name, $default);\n\t}\n\n/**\n * End a capturing block. The compliment to View::start()\n *\n * @return void\n * @see ViewBlock::end()\n */\n\tpublic function end() {\n\t\treturn $this->Blocks->end();\n\t}\n\n/**\n * Provides view or element extension/inheritance. Views can extends a\n * parent view and populate blocks in the parent template.\n *\n * @param string $name The view or element to 'extend' the current one with.\n * @return void\n * @throws LogicException when you extend a view with itself or make extend loops.\n * @throws LogicException when you extend an element which doesn't exist\n */\n\tpublic function extend($name) {\n\t\tif ($name[0] === '/' || $this->_currentType === self::TYPE_VIEW) {\n\t\t\t$parent = $this->_getViewFileName($name);\n\t\t} else {\n\t\t\tswitch ($this->_currentType) {\n\t\t\t\tcase self::TYPE_ELEMENT:\n\t\t\t\t\t$parent = $this->_getElementFileName($name);\n\t\t\t\t\tif (!$parent) {\n\t\t\t\t\t\tlist($plugin, $name) = $this->pluginSplit($name);\n\t\t\t\t\t\t$paths = $this->_paths($plugin);\n\t\t\t\t\t\t$defaultPath = $paths[0] . 'Elements' . DS;\n\t\t\t\t\t\tthrow new LogicException(__d(\n\t\t\t\t\t\t\t'cake_dev',\n\t\t\t\t\t\t\t'You cannot extend an element which does not exist (%s).',\n\t\t\t\t\t\t\t$defaultPath . $name . $this->ext\n\t\t\t\t\t\t));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase self::TYPE_LAYOUT:\n\t\t\t\t\t$parent = $this->_getLayoutFileName($name);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t$parent = $this->_getViewFileName($name);\n\t\t\t}\n\t\t}\n\n\t\tif ($parent == $this->_current) {\n\t\t\tthrow new LogicException(__d('cake_dev', 'You cannot have views extend themselves.'));\n\t\t}\n\t\tif (isset($this->_parents[$parent]) && $this->_parents[$parent] == $this->_current) {\n\t\t\tthrow new LogicException(__d('cake_dev', 'You cannot have views extend in a loop.'));\n\t\t}\n\t\t$this->_parents[$this->_current] = $parent;\n\t}\n\n/**\n * Adds a script block or other element to be inserted in $scripts_for_layout in\n * the `<head />` of a document layout\n *\n * @param string $name Either the key name for the script, or the script content. Name can be used to\n *   update/replace a script element.\n * @param string $content The content of the script being added, optional.\n * @return void\n * @deprecated Will be removed in 3.0. Superseded by blocks functionality.\n * @see View::start()\n */\n\tpublic function addScript($name, $content = null) {\n\t\tif (empty($content)) {\n\t\t\tif (!in_array($name, array_values($this->_scripts))) {\n\t\t\t\t$this->_scripts[] = $name;\n\t\t\t}\n\t\t} else {\n\t\t\t$this->_scripts[$name] = $content;\n\t\t}\n\t}\n\n/**\n * Generates a unique, non-random DOM ID for an object, based on the object type and the target URL.\n *\n * @param string $object Type of object, i.e. 'form' or 'link'\n * @param string $url The object's target URL\n * @return string\n */\n\tpublic function uuid($object, $url) {\n\t\t$c = 1;\n\t\t$url = Router::url($url);\n\t\t$hash = $object . substr(md5($object . $url), 0, 10);\n\t\twhile (in_array($hash, $this->uuids)) {\n\t\t\t$hash = $object . substr(md5($object . $url . $c), 0, 10);\n\t\t\t$c++;\n\t\t}\n\t\t$this->uuids[] = $hash;\n\t\treturn $hash;\n\t}\n\n/**\n * Allows a template or element to set a variable that will be available in\n * a layout or other element. Analogous to Controller::set().\n *\n * @param string|array $one A string or an array of data.\n * @param string|array $two Value in case $one is a string (which then works as the key).\n *    Unused if $one is an associative array, otherwise serves as the values to $one's keys.\n * @return void\n */\n\tpublic function set($one, $two = null) {\n\t\t$data = null;\n\t\tif (is_array($one)) {\n\t\t\tif (is_array($two)) {\n\t\t\t\t$data = array_combine($one, $two);\n\t\t\t} else {\n\t\t\t\t$data = $one;\n\t\t\t}\n\t\t} else {\n\t\t\t$data = array($one => $two);\n\t\t}\n\t\tif (!$data) {\n\t\t\treturn false;\n\t\t}\n\t\t$this->viewVars = $data + $this->viewVars;\n\t}\n\n/**\n * Magic accessor for helpers. Provides access to attributes that were deprecated.\n *\n * @param string $name Name of the attribute to get.\n * @return mixed\n */\n\tpublic function __get($name) {\n\t\tswitch ($name) {\n\t\t\tcase 'base':\n\t\t\tcase 'here':\n\t\t\tcase 'webroot':\n\t\t\tcase 'data':\n\t\t\t\treturn $this->request->{$name};\n\t\t\tcase 'action':\n\t\t\t\treturn $this->request->params['action'];\n\t\t\tcase 'params':\n\t\t\t\treturn $this->request;\n\t\t\tcase 'output':\n\t\t\t\treturn $this->Blocks->get('content');\n\t\t}\n\t\tif (isset($this->Helpers->{$name})) {\n\t\t\t$this->{$name} = $this->Helpers->{$name};\n\t\t\treturn $this->Helpers->{$name};\n\t\t}\n\t\treturn $this->{$name};\n\t}\n\n/**\n * Magic accessor for deprecated attributes.\n *\n * @param string $name Name of the attribute to set.\n * @param string $value Value of the attribute to set.\n * @return mixed\n */\n\tpublic function __set($name, $value) {\n\t\tswitch ($name) {\n\t\t\tcase 'output':\n\t\t\t\treturn $this->Blocks->set('content', $value);\n\t\t\tdefault:\n\t\t\t\t$this->{$name} = $value;\n\t\t}\n\t}\n\n/**\n * Magic isset check for deprecated attributes.\n *\n * @param string $name Name of the attribute to check.\n * @return boolean\n */\n\tpublic function __isset($name) {\n\t\tif (isset($this->{$name})) {\n\t\t\treturn true;\n\t\t}\n\t\t$magicGet = array('base', 'here', 'webroot', 'data', 'action', 'params', 'output');\n\t\tif (in_array($name, $magicGet)) {\n\t\t\treturn $this->__get($name) !== null;\n\t\t}\n\t\treturn false;\n\t}\n\n/**\n * Interact with the HelperCollection to load all the helpers.\n *\n * @return void\n */\n\tpublic function loadHelpers() {\n\t\t$helpers = HelperCollection::normalizeObjectArray($this->helpers);\n\t\tforeach ($helpers as $properties) {\n\t\t\tlist(, $class) = pluginSplit($properties['class']);\n\t\t\t$this->{$class} = $this->Helpers->load($properties['class'], $properties['settings']);\n\t\t}\n\t\t$this->_helpersLoaded = true;\n\t}\n\n/**\n * Renders and returns output for given view filename with its\n * array of data. Handles parent/extended views.\n *\n * @param string $viewFile Filename of the view\n * @param array $data Data to include in rendered view. If empty the current View::$viewVars will be used.\n * @return string Rendered output\n * @throws CakeException when a block is left open.\n */\n\tprotected function _render($viewFile, $data = array()) {\n\t\tif (empty($data)) {\n\t\t\t$data = $this->viewVars;\n\t\t}\n\t\t$this->_current = $viewFile;\n\t\t$initialBlocks = count($this->Blocks->unclosed());\n\n\t\t$eventManager = $this->getEventManager();\n\t\t$beforeEvent = new CakeEvent('View.beforeRenderFile', $this, array($viewFile));\n\n\t\t$eventManager->dispatch($beforeEvent);\n\t\t$content = $this->_evaluate($viewFile, $data);\n\n\t\t$afterEvent = new CakeEvent('View.afterRenderFile', $this, array($viewFile, $content));\n\n\t\t$afterEvent->modParams = 1;\n\t\t$eventManager->dispatch($afterEvent);\n\t\t$content = $afterEvent->data[1];\n\n\t\tif (isset($this->_parents[$viewFile])) {\n\t\t\t$this->_stack[] = $this->fetch('content');\n\t\t\t$this->assign('content', $content);\n\n\t\t\t$content = $this->_render($this->_parents[$viewFile]);\n\t\t\t$this->assign('content', array_pop($this->_stack));\n\t\t}\n\n\t\t$remainingBlocks = count($this->Blocks->unclosed());\n\n\t\tif ($initialBlocks !== $remainingBlocks) {\n\t\t\tthrow new CakeException(__d('cake_dev', 'The \"%s\" block was left open. Blocks are not allowed to cross files.', $this->Blocks->active()));\n\t\t}\n\n\t\treturn $content;\n\t}\n\n/**\n * Sandbox method to evaluate a template / view script in.\n *\n * @param string $viewFn Filename of the view\n * @param array $dataForView Data to include in rendered view.\n *    If empty the current View::$viewVars will be used.\n * @return string Rendered output\n */\n\tprotected function _evaluate($viewFile, $dataForView) {\n\t\t$this->__viewFile = $viewFile;\n\t\textract($dataForView);\n\t\tob_start();\n\n\t\tinclude $this->__viewFile;\n\n\t\tunset($this->__viewFile);\n\t\treturn ob_get_clean();\n\t}\n\n/**\n * Loads a helper. Delegates to the `HelperCollection::load()` to load the helper\n *\n * @param string $helperName Name of the helper to load.\n * @param array $settings Settings for the helper\n * @return Helper a constructed helper object.\n * @see HelperCollection::load()\n */\n\tpublic function loadHelper($helperName, $settings = array()) {\n\t\treturn $this->Helpers->load($helperName, $settings);\n\t}\n\n/**\n * Returns filename of given action's template file (.ctp) as a string.\n * CamelCased action names will be under_scored! This means that you can have\n * LongActionNames that refer to long_action_names.ctp views.\n *\n * @param string $name Controller action to find template filename for\n * @return string Template filename\n * @throws MissingViewException when a view file could not be found.\n */\n\tprotected function _getViewFileName($name = null) {\n\t\t$subDir = null;\n\n\t\tif (!is_null($this->subDir)) {\n\t\t\t$subDir = $this->subDir . DS;\n\t\t}\n\n\t\tif ($name === null) {\n\t\t\t$name = $this->view;\n\t\t}\n\t\t$name = str_replace('/', DS, $name);\n\t\tlist($plugin, $name) = $this->pluginSplit($name);\n\n\t\tif (strpos($name, DS) === false && $name[0] !== '.') {\n\t\t\t$name = $this->viewPath . DS . $subDir . Inflector::underscore($name);\n\t\t} elseif (strpos($name, DS) !== false) {\n\t\t\tif ($name[0] === DS || $name[1] === ':') {\n\t\t\t\tif (is_file($name)) {\n\t\t\t\t\treturn $name;\n\t\t\t\t}\n\t\t\t\t$name = trim($name, DS);\n\t\t\t} elseif ($name[0] === '.') {\n\t\t\t\t$name = substr($name, 3);\n\t\t\t} elseif (!$plugin || $this->viewPath !== $this->name) {\n\t\t\t\t$name = $this->viewPath . DS . $subDir . $name;\n\t\t\t}\n\t\t}\n\t\t$paths = $this->_paths($plugin);\n\t\t$exts = $this->_getExtensions();\n\t\tforeach ($exts as $ext) {\n\t\t\tforeach ($paths as $path) {\n\t\t\t\tif (file_exists($path . $name . $ext)) {\n\t\t\t\t\treturn $path . $name . $ext;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$defaultPath = $paths[0];\n\n\t\tif ($this->plugin) {\n\t\t\t$pluginPaths = App::path('plugins');\n\t\t\tforeach ($paths as $path) {\n\t\t\t\tif (strpos($path, $pluginPaths[0]) === 0) {\n\t\t\t\t\t$defaultPath = $path;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new MissingViewException(array('file' => $defaultPath . $name . $this->ext));\n\t}\n\n/**\n * Splits a dot syntax plugin name into its plugin and filename.\n * If $name does not have a dot, then index 0 will be null.\n * It checks if the plugin is loaded, else filename will stay unchanged for filenames containing dot\n *\n * @param string $name The name you want to plugin split.\n * @param boolean $fallback If true uses the plugin set in the current CakeRequest when parsed plugin is not loaded\n * @return array Array with 2 indexes. 0 => plugin name, 1 => filename\n */\n\tpublic function pluginSplit($name, $fallback = true) {\n\t\t$plugin = null;\n\t\tlist($first, $second) = pluginSplit($name);\n\t\tif (CakePlugin::loaded($first) === true) {\n\t\t\t$name = $second;\n\t\t\t$plugin = $first;\n\t\t}\n\t\tif (isset($this->plugin) && !$plugin && $fallback) {\n\t\t\t$plugin = $this->plugin;\n\t\t}\n\t\treturn array($plugin, $name);\n\t}\n\n/**\n * Returns layout filename for this template as a string.\n *\n * @param string $name The name of the layout to find.\n * @return string Filename for layout file (.ctp).\n * @throws MissingLayoutException when a layout cannot be located\n */\n\tprotected function _getLayoutFileName($name = null) {\n\t\tif ($name === null) {\n\t\t\t$name = $this->layout;\n\t\t}\n\t\t$subDir = null;\n\n\t\tif (!is_null($this->layoutPath)) {\n\t\t\t$subDir = $this->layoutPath . DS;\n\t\t}\n\t\tlist($plugin, $name) = $this->pluginSplit($name);\n\t\t$paths = $this->_paths($plugin);\n\t\t$file = 'Layouts' . DS . $subDir . $name;\n\n\t\t$exts = $this->_getExtensions();\n\t\tforeach ($exts as $ext) {\n\t\t\tforeach ($paths as $path) {\n\t\t\t\tif (file_exists($path . $file . $ext)) {\n\t\t\t\t\treturn $path . $file . $ext;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new MissingLayoutException(array('file' => $paths[0] . $file . $this->ext));\n\t}\n\n/**\n * Get the extensions that view files can use.\n *\n * @return array Array of extensions view files use.\n */\n\tprotected function _getExtensions() {\n\t\t$exts = array($this->ext);\n\t\tif ($this->ext !== '.ctp') {\n\t\t\t$exts[] = '.ctp';\n\t\t}\n\t\treturn $exts;\n\t}\n\n/**\n * Finds an element filename, returns false on failure.\n *\n * @param string $name The name of the element to find.\n * @return mixed Either a string to the element filename or false when one can't be found.\n */\n\tprotected function _getElementFileName($name) {\n\t\tlist($plugin, $name) = $this->pluginSplit($name);\n\n\t\t$paths = $this->_paths($plugin);\n\t\t$exts = $this->_getExtensions();\n\t\tforeach ($exts as $ext) {\n\t\t\tforeach ($paths as $path) {\n\t\t\t\tif (file_exists($path . 'Elements' . DS . $name . $ext)) {\n\t\t\t\t\treturn $path . 'Elements' . DS . $name . $ext;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n/**\n * Return all possible paths to find view files in order\n *\n * @param string $plugin Optional plugin name to scan for view files.\n * @param boolean $cached Set to true to force a refresh of view paths.\n * @return array paths\n */\n\tprotected function _paths($plugin = null, $cached = true) {\n\t\tif ($plugin === null && $cached === true && !empty($this->_paths)) {\n\t\t\treturn $this->_paths;\n\t\t}\n\t\t$paths = array();\n\t\t$viewPaths = App::path('View');\n\t\t$corePaths = array_merge(App::core('View'), App::core('Console/Templates/skel/View'));\n\n\t\tif (!empty($plugin)) {\n\t\t\t$count = count($viewPaths);\n\t\t\tfor ($i = 0; $i < $count; $i++) {\n\t\t\t\tif (!in_array($viewPaths[$i], $corePaths)) {\n\t\t\t\t\t$paths[] = $viewPaths[$i] . 'Plugin' . DS . $plugin . DS;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$paths = array_merge($paths, App::path('View', $plugin));\n\t\t}\n\n\t\t$paths = array_unique(array_merge($paths, $viewPaths));\n\t\tif (!empty($this->theme)) {\n\t\t\t$theme = Inflector::camelize($this->theme);\n\t\t\t$themePaths = array();\n\t\t\tforeach ($paths as $path) {\n\t\t\t\tif (strpos($path, DS . 'Plugin' . DS) === false) {\n\t\t\t\t\tif ($plugin) {\n\t\t\t\t\t\t$themePaths[] = $path . 'Themed' . DS . $theme . DS . 'Plugin' . DS . $plugin . DS;\n\t\t\t\t\t}\n\t\t\t\t\t$themePaths[] = $path . 'Themed' . DS . $theme . DS;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$paths = array_merge($themePaths, $paths);\n\t\t}\n\t\t$paths = array_merge($paths, $corePaths);\n\t\tif ($plugin !== null) {\n\t\t\treturn $paths;\n\t\t}\n\t\treturn $this->_paths = $paths;\n\t}\n\n/**\n * Checks if an element is cached and returns the cached data if present\n *\n * @param string $name Element name\n * @param string $data Data\n * @param array $options Element options\n * @return string|null\n */\n\tprotected function _elementCache($name, $data, $options) {\n\t\t$plugin = null;\n\t\tlist($plugin, $name) = $this->pluginSplit($name);\n\n\t\t$underscored = null;\n\t\tif ($plugin) {\n\t\t\t$underscored = Inflector::underscore($plugin);\n\t\t}\n\t\t$keys = array_merge(array($underscored, $name), array_keys($options), array_keys($data));\n\t\t$this->elementCacheSettings = array(\n\t\t\t'config' => $this->elementCache,\n\t\t\t'key' => implode('_', $keys)\n\t\t);\n\t\tif (is_array($options['cache'])) {\n\t\t\t$defaults = array(\n\t\t\t\t'config' => $this->elementCache,\n\t\t\t\t'key' => $this->elementCacheSettings['key']\n\t\t\t);\n\t\t\t$this->elementCacheSettings = array_merge($defaults, $options['cache']);\n\t\t}\n\t\t$this->elementCacheSettings['key'] = 'element_' . $this->elementCacheSettings['key'];\n\t\treturn Cache::read($this->elementCacheSettings['key'], $this->elementCacheSettings['config']);\n\t}\n\n/**\n * Renders an element and fires the before and afterRender callbacks for it\n * and writes to the cache if a cache is used\n *\n * @param string $file Element file path\n * @param array $data Data to render\n * @param array $options Element options\n * @return string\n */\n\tprotected function _renderElement($file, $data, $options) {\n\t\tif (!$this->_helpersLoaded) {\n\t\t\t$this->loadHelpers();\n\t\t}\n\t\tif ($options['callbacks']) {\n\t\t\t$this->getEventManager()->dispatch(new CakeEvent('View.beforeRender', $this, array($file)));\n\t\t}\n\n\t\t$current = $this->_current;\n\t\t$restore = $this->_currentType;\n\n\t\t$this->_currentType = self::TYPE_ELEMENT;\n\t\t$element = $this->_render($file, array_merge($this->viewVars, $data));\n\n\t\t$this->_currentType = $restore;\n\t\t$this->_current = $current;\n\n\t\tif ($options['callbacks']) {\n\t\t\t$this->getEventManager()->dispatch(new CakeEvent('View.afterRender', $this, array($file, $element)));\n\t\t}\n\t\tif (isset($options['cache'])) {\n\t\t\tCache::write($this->elementCacheSettings['key'], $element, $this->elementCacheSettings['config']);\n\t\t}\n\t\treturn $element;\n\t}\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":35007}]],"length":35007}
