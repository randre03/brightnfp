{"ts":1377222182183,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"<?php\n/**\n * CakePHP(tm) : Rapid Development Framework (http://cakephp.org)\n * Copyright (c) Cake Software Foundation, Inc. (http://cakefoundation.org)\n *\n * Licensed under The MIT License\n * For full copyright and license information, please see the LICENSE.txt\n * Redistributions of files must retain the above copyright notice.\n *\n * @copyright     Copyright (c) Cake Software Foundation, Inc. (http://cakefoundation.org)\n * @link          http://cakephp.org CakePHP(tm) Project\n * @package       Cake.View\n * @since         CakePHP(tm) v 0.2.9\n * @license       http://www.opensource.org/licenses/mit-license.php MIT License\n */\n\nApp::uses('Router', 'Routing');\nApp::uses('Hash', 'Utility');\n\n/**\n * Abstract base class for all other Helpers in CakePHP.\n * Provides common methods and features.\n *\n * @package       Cake.View\n */\nclass Helper extends Object {\n\n/**\n * Settings for this helper.\n *\n * @var array\n */\n\tpublic $settings = array();\n\n/**\n * List of helpers used by this helper\n *\n * @var array\n */\n\tpublic $helpers = array();\n\n/**\n * A helper lookup table used to lazy load helper objects.\n *\n * @var array\n */\n\tprotected $_helperMap = array();\n\n/**\n * The current theme name if any.\n *\n * @var string\n */\n\tpublic $theme = null;\n\n/**\n * Request object\n *\n * @var CakeRequest\n */\n\tpublic $request = null;\n\n/**\n * Plugin path\n *\n * @var string\n */\n\tpublic $plugin = null;\n\n/**\n * Holds the fields array('field_name' => array('type' => 'string', 'length' => 100),\n * primaryKey and validates array('field_name')\n *\n * @var array\n */\n\tpublic $fieldset = array();\n\n/**\n * Holds tag templates.\n *\n * @var array\n */\n\tpublic $tags = array();\n\n/**\n * Holds the content to be cleaned.\n *\n * @var mixed\n */\n\tprotected $_tainted = null;\n\n/**\n * Holds the cleaned content.\n *\n * @var mixed\n */\n\tprotected $_cleaned = null;\n\n/**\n * The View instance this helper is attached to\n *\n * @var View\n */\n\tprotected $_View;\n\n/**\n * A list of strings that should be treated as suffixes, or\n * sub inputs for a parent input. This is used for date/time\n * inputs primarily.\n *\n * @var array\n */\n\tprotected $_fieldSuffixes = array(\n\t\t'year', 'month', 'day', 'hour', 'min', 'second', 'meridian'\n\t);\n\n/**\n * The name of the current model entities are in scope of.\n *\n * @see Helper::setEntity()\n * @var string\n */\n\tprotected $_modelScope;\n\n/**\n * The name of the current model association entities are in scope of.\n *\n * @see Helper::setEntity()\n * @var string\n */\n\tprotected $_association;\n\n/**\n * The dot separated list of elements the current field entity is for.\n *\n * @see Helper::setEntity()\n * @var string\n */\n\tprotected $_entityPath;\n\n/**\n * Minimized attributes\n *\n * @var array\n */\n\tprotected $_minimizedAttributes = array(\n\t\t'compact', 'checked', 'declare', 'readonly', 'disabled', 'selected',\n\t\t'defer', 'ismap', 'nohref', 'noshade', 'nowrap', 'multiple', 'noresize',\n\t\t'autoplay', 'controls', 'loop', 'muted', 'required', 'novalidate', 'formnovalidate'\n\t);\n\n/**\n * Format to attribute\n *\n * @var string\n */\n\tprotected $_attributeFormat = '%s=\"%s\"';\n\n/**\n * Format to attribute\n *\n * @var string\n */\n\tprotected $_minimizedAttributeFormat = '%s=\"%s\"';\n\n/**\n * Default Constructor\n *\n * @param View $View The View this helper is being attached to.\n * @param array $settings Configuration settings for the helper.\n */\n\tpublic function __construct(View $View, $settings = array()) {\n\t\t$this->_View = $View;\n\t\t$this->request = $View->request;\n\t\tif ($settings) {\n\t\t\t$this->settings = Hash::merge($this->settings, $settings);\n\t\t}\n\t\tif (!empty($this->helpers)) {\n\t\t\t$this->_helperMap = ObjectCollection::normalizeObjectArray($this->helpers);\n\t\t}\n\t}\n\n/**\n * Provide non fatal errors on missing method calls.\n *\n * @param string $method Method to invoke\n * @param array $params Array of params for the method.\n * @return void\n */\n\tpublic function __call($method, $params) {\n\t\ttrigger_error(__d('cake_dev', 'Method %1$s::%2$s does not exist', get_class($this), $method), E_USER_WARNING);\n\t}\n\n/**\n * Lazy loads helpers. Provides access to deprecated request properties as well.\n *\n * @param string $name Name of the property being accessed.\n * @return mixed Helper or property found at $name\n */\n\tpublic function __get($name) {\n\t\tif (isset($this->_helperMap[$name]) && !isset($this->{$name})) {\n\t\t\t$settings = array_merge((array)$this->_helperMap[$name]['settings'], array('enabled' => false));\n\t\t\t$this->{$name} = $this->_View->loadHelper($this->_helperMap[$name]['class'], $settings);\n\t\t}\n\t\tif (isset($this->{$name})) {\n\t\t\treturn $this->{$name};\n\t\t}\n\t\tswitch ($name) {\n\t\t\tcase 'base':\n\t\t\tcase 'here':\n\t\t\tcase 'webroot':\n\t\t\tcase 'data':\n\t\t\t\treturn $this->request->{$name};\n\t\t\tcase 'action':\n\t\t\t\treturn isset($this->request->params['action']) ? $this->request->params['action'] : '';\n\t\t\tcase 'params':\n\t\t\t\treturn $this->request;\n\t\t}\n\t}\n\n/**\n * Provides backwards compatibility access for setting values to the request object.\n *\n * @param string $name Name of the property being accessed.\n * @param mixed $value\n * @return mixed Return the $value\n */\n\tpublic function __set($name, $value) {\n\t\tswitch ($name) {\n\t\t\tcase 'base':\n\t\t\tcase 'here':\n\t\t\tcase 'webroot':\n\t\t\tcase 'data':\n\t\t\t\treturn $this->request->{$name} = $value;\n\t\t\tcase 'action':\n\t\t\t\treturn $this->request->params['action'] = $value;\n\t\t}\n\t\treturn $this->{$name} = $value;\n\t}\n\n/**\n * Finds URL for specified action.\n *\n * Returns an URL pointing at the provided parameters.\n *\n * @param string|array $url Either a relative string url like `/products/view/23` or\n *    an array of url parameters. Using an array for URLs will allow you to leverage\n *    the reverse routing features of CakePHP.\n * @param boolean $full If true, the full base URL will be prepended to the result\n * @return string Full translated URL with base path.\n * @link http://book.cakephp.org/2.0/en/views/helpers.html\n */\n\tpublic function url($url = null, $full = false) {\n\t\treturn h(Router::url($url, $full));\n\t}\n\n/**\n * Checks if a file exists when theme is used, if no file is found default location is returned\n *\n * @param string $file The file to create a webroot path to.\n * @return string Web accessible path to file.\n */\n\tpublic function webroot($file) {\n\t\t$asset = explode('?', $file);\n\t\t$asset[1] = isset($asset[1]) ? '?' . $asset[1] : null;\n\t\t$webPath = \"{$this->request->webroot}\" . $asset[0];\n\t\t$file = $asset[0];\n\n\t\tif (!empty($this->theme)) {\n\t\t\t$file = trim($file, '/');\n\t\t\t$theme = $this->theme . '/';\n\n\t\t\tif (DS === '\\\\') {\n\t\t\t\t$file = str_replace('/', '\\\\', $file);\n\t\t\t}\n\n\t\t\tif (file_exists(Configure::read('App.www_root') . 'theme' . DS . $this->theme . DS . $file)) {\n\t\t\t\t$webPath = \"{$this->request->webroot}theme/\" . $theme . $asset[0];\n\t\t\t} else {\n\t\t\t\t$themePath = App::themePath($this->theme);\n\t\t\t\t$path = $themePath . 'webroot' . DS . $file;\n\t\t\t\tif (file_exists($path)) {\n\t\t\t\t\t$webPath = \"{$this->request->webroot}theme/\" . $theme . $asset[0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (strpos($webPath, '//') !== false) {\n\t\t\treturn str_replace('//', '/', $webPath . $asset[1]);\n\t\t}\n\t\treturn $webPath . $asset[1];\n\t}\n\n/**\n * Generate url for given asset file. Depending on options passed provides full url with domain name.\n * Also calls Helper::assetTimestamp() to add timestamp to local files\n *\n * @param string|array Path string or url array\n * @param array $options Options array. Possible keys:\n *   `fullBase` Return full url with domain name\n *   `pathPrefix` Path prefix for relative URLs\n *   `ext` Asset extension to append\n *   `plugin` False value will prevent parsing path as a plugin\n * @return string Generated url\n */\n\tpublic function assetUrl($path, $options = array()) {\n\t\tif (is_array($path)) {\n\t\t\treturn $this->url($path, !empty($options['fullBase']));\n\t\t}\n\t\tif (strpos($path, '://') !== false) {\n\t\t\treturn $path;\n\t\t}\n\t\tif (!array_key_exists('plugin', $options) || $options['plugin'] !== false) {\n\t\t\tlist($plugin, $path) = $this->_View->pluginSplit($path, false);\n\t\t}\n\t\tif (!empty($options['pathPrefix']) && $path[0] !== '/') {\n\t\t\t$path = $options['pathPrefix'] . $path;\n\t\t}\n\t\tif (\n\t\t\t!empty($options['ext']) &&\n\t\t\tstrpos($path, '?') === false &&\n\t\t\tsubstr($path, -strlen($options['ext'])) !== $options['ext']\n\t\t) {\n\t\t\t$path .= $options['ext'];\n\t\t}\n\t\tif (isset($plugin)) {\n\t\t\t$path = Inflector::underscore($plugin) . '/' . $path;\n\t\t}\n\t\t$path = $this->_encodeUrl($this->assetTimestamp($this->webroot($path)));\n\n\t\tif (!empty($options['fullBase'])) {\n\t\t\t$path = rtrim(FULL_BASE_URL, '/') . '/' . ltrim($path, '/');\n\t\t}\n\t\treturn $path;\n\t}\n\n/**\n * Encodes an URL for use in HTML attributes.\n *\n * @param string $url The url to encode.\n * @return string The url encoded for both URL & HTML contexts.\n */\n\tprotected function _encodeUrl($url) {\n\t\t$path = parse_url($url, PHP_URL_PATH);\n\t\t$parts = array_map('urldecode', explode('/', $path));\n\t\t$parts = array_map('rawurlencode', $parts);\n\t\t$encoded = implode('/', $parts);\n\t\treturn h(str_replace($path, $encoded, $url));\n\t}\n\n/**\n * Adds a timestamp to a file based resource based on the value of `Asset.timestamp` in\n * Configure. If Asset.timestamp is true and debug > 0, or Asset.timestamp === 'force'\n * a timestamp will be added.\n *\n * @param string $path The file path to timestamp, the path must be inside WWW_ROOT\n * @return string Path with a timestamp added, or not.\n */\n\tpublic function assetTimestamp($path) {\n\t\t$stamp = Configure::read('Asset.timestamp');\n\t\t$timestampEnabled = $stamp === 'force' || ($stamp === true && Configure::read('debug') > 0);\n\t\tif ($timestampEnabled && strpos($path, '?') === false) {\n\t\t\t$filepath = preg_replace(\n\t\t\t\t'/^' . preg_quote($this->request->webroot, '/') . '/',\n\t\t\t\t'',\n\t\t\t\turldecode($path)\n\t\t\t);\n\t\t\t$webrootPath = WWW_ROOT . str_replace('/', DS, $filepath);\n\t\t\tif (file_exists($webrootPath)) {\n\t\t\t\t//@codingStandardsIgnoreStart\n\t\t\t\treturn $path . '?' . @filemtime($webrootPath);\n\t\t\t\t//@codingStandardsIgnoreEnd\n\t\t\t}\n\t\t\t$segments = explode('/', ltrim($filepath, '/'));\n\t\t\tif ($segments[0] === 'theme') {\n\t\t\t\t$theme = $segments[1];\n\t\t\t\tunset($segments[0], $segments[1]);\n\t\t\t\t$themePath = App::themePath($theme) . 'webroot' . DS . implode(DS, $segments);\n\t\t\t\t//@codingStandardsIgnoreStart\n\t\t\t\treturn $path . '?' . @filemtime($themePath);\n\t\t\t\t//@codingStandardsIgnoreEnd\n\t\t\t} else {\n\t\t\t\t$plugin = Inflector::camelize($segments[0]);\n\t\t\t\tif (CakePlugin::loaded($plugin)) {\n\t\t\t\t\tunset($segments[0]);\n\t\t\t\t\t$pluginPath = CakePlugin::path($plugin) . 'webroot' . DS . implode(DS, $segments);\n\t\t\t\t\t//@codingStandardsIgnoreStart\n\t\t\t\t\treturn $path . '?' . @filemtime($pluginPath);\n\t\t\t\t\t//@codingStandardsIgnoreEnd\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $path;\n\t}\n\n/**\n * Used to remove harmful tags from content. Removes a number of well known XSS attacks\n * from content. However, is not guaranteed to remove all possibilities. Escaping\n * content is the best way to prevent all possible attacks.\n *\n * @param string|array $output Either an array of strings to clean or a single string to clean.\n * @return string|array cleaned content for output\n */\n\tpublic function clean($output) {\n\t\t$this->_reset();\n\t\tif (empty($output)) {\n\t\t\treturn null;\n\t\t}\n\t\tif (is_array($output)) {\n\t\t\tforeach ($output as $key => $value) {\n\t\t\t\t$return[$key] = $this->clean($value);\n\t\t\t}\n\t\t\treturn $return;\n\t\t}\n\t\t$this->_tainted = $output;\n\t\t$this->_clean();\n\t\treturn $this->_cleaned;\n\t}\n\n/**\n * Returns a space-delimited string with items of the $options array. If a key\n * of $options array happens to be one of those listed in `Helper::$_minimizedAttributes`\n *\n * And its value is one of:\n *\n * - '1' (string)\n * - 1 (integer)\n * - true (boolean)\n * - 'true' (string)\n *\n * Then the value will be reset to be identical with key's name.\n * If the value is not one of these 3, the parameter is not output.\n *\n * 'escape' is a special option in that it controls the conversion of\n *  attributes to their html-entity encoded equivalents. Set to false to disable html-encoding.\n *\n * If value for any option key is set to `null` or `false`, that option will be excluded from output.\n *\n * @param array $options Array of options.\n * @param array $exclude Array of options to be excluded, the options here will not be part of the return.\n * @param string $insertBefore String to be inserted before options.\n * @param string $insertAfter String to be inserted after options.\n * @return string Composed attributes.\n * @deprecated This method will be moved to HtmlHelper in 3.0\n */\n\tprotected function _parseAttributes($options, $exclude = null, $insertBefore = ' ', $insertAfter = null) {\n\t\tif (!is_string($options)) {\n\t\t\t$options = (array)$options + array('escape' => true);\n\n\t\t\tif (!is_array($exclude)) {\n\t\t\t\t$exclude = array();\n\t\t\t}\n\n\t\t\t$exclude = array('escape' => true) + array_flip($exclude);\n\t\t\t$escape = $options['escape'];\n\t\t\t$attributes = array();\n\n\t\t\tforeach ($options as $key => $value) {\n\t\t\t\tif (!isset($exclude[$key]) && $value !== false && $value !== null) {\n\t\t\t\t\t$attributes[] = $this->_formatAttribute($key, $value, $escape);\n\t\t\t\t}\n\t\t\t}\n\t\t\t$out = implode(' ', $attributes);\n\t\t} else {\n\t\t\t$out = $options;\n\t\t}\n\t\treturn $out ? $insertBefore . $out . $insertAfter : '';\n\t}\n\n/**\n * Formats an individual attribute, and returns the string value of the composed attribute.\n * Works with minimized attributes that have the same value as their name such as 'disabled' and 'checked'\n *\n * @param string $key The name of the attribute to create\n * @param string $value The value of the attribute to create.\n * @param boolean $escape Define if the value must be escaped\n * @return string The composed attribute.\n * @deprecated This method will be moved to HtmlHelper in 3.0\n */\n\tprotected function _formatAttribute($key, $value, $escape = true) {\n\t\tif (is_array($value)) {\n\t\t\t$value = implode(' ' , $value);\n\t\t}\n\t\tif (is_numeric($key)) {\n\t\t\treturn sprintf($this->_minimizedAttributeFormat, $value, $value);\n\t\t}\n\t\t$truthy = array(1, '1', true, 'true', $key);\n\t\t$isMinimized = in_array($key, $this->_minimizedAttributes);\n\t\tif ($isMinimized && in_array($value, $truthy, true)) {\n\t\t\treturn sprintf($this->_minimizedAttributeFormat, $key, $key);\n\t\t}\n\t\tif ($isMinimized) {\n\t\t\treturn '';\n\t\t}\n\t\treturn sprintf($this->_attributeFormat, $key, ($escape ? h($value) : $value));\n\t}\n\n/**\n * Sets this helper's model and field properties to the dot-separated value-pair in $entity.\n *\n * @param string $entity A field name, like \"ModelName.fieldName\" or \"ModelName.ID.fieldName\"\n * @param boolean $setScope Sets the view scope to the model specified in $tagValue\n * @return void\n */\n\tpublic function setEntity($entity, $setScope = false) {\n\t\tif ($entity === null) {\n\t\t\t$this->_modelScope = false;\n\t\t}\n\t\tif ($setScope === true) {\n\t\t\t$this->_modelScope = $entity;\n\t\t}\n\t\t$parts = array_values(Hash::filter(explode('.', $entity)));\n\t\tif (empty($parts)) {\n\t\t\treturn;\n\t\t}\n\t\t$count = count($parts);\n\t\t$lastPart = isset($parts[$count - 1]) ? $parts[$count - 1] : null;\n\n\t\t// Either 'body' or 'date.month' type inputs.\n\t\tif (\n\t\t\t($count === 1 && $this->_modelScope && !$setScope) ||\n\t\t\t(\n\t\t\t\t$count === 2 &&\n\t\t\t\tin_array($lastPart, $this->_fieldSuffixes) &&\n\t\t\t\t$this->_modelScope &&\n\t\t\t\t$parts[0] !== $this->_modelScope\n\t\t\t)\n\t\t) {\n\t\t\t$entity = $this->_modelScope . '.' . $entity;\n\t\t}\n\n\t\t// 0.name, 0.created.month style inputs. Excludes inputs with the modelScope in them.\n\t\tif (\n\t\t\t$count >= 2 &&\n\t\t\tis_numeric($parts[0]) &&\n\t\t\t!is_numeric($parts[1]) &&\n\t\t\t$this->_modelScope &&\n\t\t\tstrpos($entity, $this->_modelScope) === false\n\t\t) {\n\t\t\t$entity = $this->_modelScope . '.' . $entity;\n\t\t}\n\n\t\t$this->_association = null;\n\n\t\t$isHabtm = (\n\t\t\tisset($this->fieldset[$this->_modelScope]['fields'][$parts[0]]['type']) &&\n\t\t\t$this->fieldset[$this->_modelScope]['fields'][$parts[0]]['type'] === 'multiple'\n\t\t);\n\n\t\t// habtm models are special\n\t\tif ($count === 1 && $isHabtm) {\n\t\t\t$this->_association = $parts[0];\n\t\t\t$entity = $parts[0] . '.' . $parts[0];\n\t\t} else {\n\t\t\t// check for associated model.\n\t\t\t$reversed = array_reverse($parts);\n\t\t\tforeach ($reversed as $i => $part) {\n\t\t\t\tif ($i > 0 && preg_match('/^[A-Z]/', $part)) {\n\t\t\t\t\t$this->_association = $part;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$this->_entityPath = $entity;\n\t}\n\n/**\n * Returns the entity reference of the current context as an array of identity parts\n *\n * @return array An array containing the identity elements of an entity\n */\n\tpublic function entity() {\n\t\treturn explode('.', $this->_entityPath);\n\t}\n\n/**\n * Gets the currently-used model of the rendering context.\n *\n * @return string\n */\n\tpublic function model() {\n\t\tif ($this->_association) {\n\t\t\treturn $this->_association;\n\t\t}\n\t\treturn $this->_modelScope;\n\t}\n\n/**\n * Gets the currently-used model field of the rendering context.\n * Strips off field suffixes such as year, month, day, hour, min, meridian\n * when the current entity is longer than 2 elements.\n *\n * @return string\n */\n\tpublic function field() {\n\t\t$entity = $this->entity();\n\t\t$count = count($entity);\n\t\t$last = $entity[$count - 1];\n\t\tif ($count > 2 && in_array($last, $this->_fieldSuffixes)) {\n\t\t\t$last = isset($entity[$count - 2]) ? $entity[$count - 2] : null;\n\t\t}\n\t\treturn $last;\n\t}\n\n/**\n * Generates a DOM ID for the selected element, if one is not set.\n * Uses the current View::entity() settings to generate a CamelCased id attribute.\n *\n * @param array|string $options Either an array of html attributes to add $id into, or a string\n *   with a view entity path to get a domId for.\n * @param string $id The name of the 'id' attribute.\n * @return mixed If $options was an array, an array will be returned with $id set. If a string\n *   was supplied, a string will be returned.\n */\n\tpublic function domId($options = null, $id = 'id') {\n\t\tif (is_array($options) && array_key_exists($id, $options) && $options[$id] === null) {\n\t\t\tunset($options[$id]);\n\t\t\treturn $options;\n\t\t} elseif (!is_array($options) && $options !== null) {\n\t\t\t$this->setEntity($options);\n\t\t\treturn $this->domId();\n\t\t}\n\n\t\t$entity = $this->entity();\n\t\t$model = array_shift($entity);\n\t\t$dom = $model . implode('', array_map(array('Inflector', 'camelize'), $entity));\n\n\t\tif (is_array($options) && !array_key_exists($id, $options)) {\n\t\t\t$options[$id] = $dom;\n\t\t} elseif ($options === null) {\n\t\t\treturn $dom;\n\t\t}\n\t\treturn $options;\n\t}\n\n/**\n * Gets the input field name for the current tag. Creates input name attributes\n * using CakePHP's data[Model][field] formatting.\n *\n * @param array|string $options If an array, should be an array of attributes that $key needs to be added to.\n *   If a string or null, will be used as the View entity.\n * @param string $field\n * @param string $key The name of the attribute to be set, defaults to 'name'\n * @return mixed If an array was given for $options, an array with $key set will be returned.\n *   If a string was supplied a string will be returned.\n */\n\tprotected function _name($options = array(), $field = null, $key = 'name') {\n\t\tif ($options === null) {\n\t\t\t$options = array();\n\t\t} elseif (is_string($options)) {\n\t\t\t$field = $options;\n\t\t\t$options = 0;\n\t\t}\n\n\t\tif (!empty($field)) {\n\t\t\t$this->setEntity($field);\n\t\t}\n\n\t\tif (is_array($options) && array_key_exists($key, $options)) {\n\t\t\treturn $options;\n\t\t}\n\n\t\tswitch ($field) {\n\t\t\tcase '_method':\n\t\t\t\t$name = $field;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t$name = 'data[' . implode('][', $this->entity()) . ']';\n\t\t}\n\n\t\tif (is_array($options)) {\n\t\t\t$options[$key] = $name;\n\t\t\treturn $options;\n\t\t}\n\t\treturn $name;\n\t}\n\n/**\n * Gets the data for the current tag\n *\n * @param array|string $options If an array, should be an array of attributes that $key needs to be added to.\n *   If a string or null, will be used as the View entity.\n * @param string $field\n * @param string $key The name of the attribute to be set, defaults to 'value'\n * @return mixed If an array was given for $options, an array with $key set will be returned.\n *   If a string was supplied a string will be returned.\n */\n\tpublic function value($options = array(), $field = null, $key = 'value') {\n\t\tif ($options === null) {\n\t\t\t$options = array();\n\t\t} elseif (is_string($options)) {\n\t\t\t$field = $options;\n\t\t\t$options = 0;\n\t\t}\n\n\t\tif (is_array($options) && isset($options[$key])) {\n\t\t\treturn $options;\n\t\t}\n\n\t\tif (!empty($field)) {\n\t\t\t$this->setEntity($field);\n\t\t}\n\t\t$result = null;\n\t\t$data = $this->request->data;\n\n\t\t$entity = $this->entity();\n\t\tif (!empty($data) && is_array($data) && !empty($entity)) {\n\t\t\t$result = Hash::get($data, implode('.', $entity));\n\t\t}\n\n\t\t$habtmKey = $this->field();\n\t\tif (empty($result) && isset($data[$habtmKey][$habtmKey]) && is_array($data[$habtmKey])) {\n\t\t\t$result = $data[$habtmKey][$habtmKey];\n\t\t} elseif (empty($result) && isset($data[$habtmKey]) && is_array($data[$habtmKey])) {\n\t\t\tif (ClassRegistry::isKeySet($habtmKey)) {\n\t\t\t\t$model = ClassRegistry::getObject($habtmKey);\n\t\t\t\t$result = $this->_selectedArray($data[$habtmKey], $model->primaryKey);\n\t\t\t}\n\t\t}\n\n\t\tif (is_array($options)) {\n\t\t\tif ($result === null && isset($options['default'])) {\n\t\t\t\t$result = $options['default'];\n\t\t\t}\n\t\t\tunset($options['default']);\n\t\t}\n\n\t\tif (is_array($options)) {\n\t\t\t$options[$key] = $result;\n\t\t\treturn $options;\n\t\t}\n\t\treturn $result;\n\t}\n\n/**\n * Sets the defaults for an input tag. Will set the\n * name, value, and id attributes for an array of html attributes.\n *\n * @param string $field The field name to initialize.\n * @param array $options Array of options to use while initializing an input field.\n * @return array Array options for the form input.\n */\n\tprotected function _initInputField($field, $options = array()) {\n\t\tif ($field !== null) {\n\t\t\t$this->setEntity($field);\n\t\t}\n\t\t$options = (array)$options;\n\t\t$options = $this->_name($options);\n\t\t$options = $this->value($options);\n\t\t$options = $this->domId($options);\n\t\treturn $options;\n\t}\n\n/**\n * Adds the given class to the element options\n *\n * @param array $options Array options/attributes to add a class to\n * @param string $class The classname being added.\n * @param string $key the key to use for class.\n * @return array Array of options with $key set.\n */\n\tpublic function addClass($options = array(), $class = null, $key = 'class') {\n\t\tif (isset($options[$key]) && trim($options[$key])) {\n\t\t\t$options[$key] .= ' ' . $class;\n\t\t} else {\n\t\t\t$options[$key] = $class;\n\t\t}\n\t\treturn $options;\n\t}\n\n/**\n * Returns a string generated by a helper method\n *\n * This method can be overridden in subclasses to do generalized output post-processing\n *\n * @param string $str String to be output.\n * @return string\n * @deprecated This method will be removed in future versions.\n */\n\tpublic function output($str) {\n\t\treturn $str;\n\t}\n\n/**\n * Before render callback. beforeRender is called before the view file is rendered.\n *\n * Overridden in subclasses.\n *\n * @param string $viewFile The view file that is going to be rendered\n * @return void\n */\n\tpublic function beforeRender($viewFile) {\n\t}\n\n/**\n * After render callback. afterRender is called after the view file is rendered\n * but before the layout has been rendered.\n *\n * Overridden in subclasses.\n *\n * @param string $viewFile The view file that was rendered.\n * @return void\n */\n\tpublic function afterRender($viewFile) {\n\t}\n\n/**\n * Before layout callback. beforeLayout is called before the layout is rendered.\n *\n * Overridden in subclasses.\n *\n * @param string $layoutFile The layout about to be rendered.\n * @return void\n */\n\tpublic function beforeLayout($layoutFile) {\n\t}\n\n/**\n * After layout callback. afterLayout is called after the layout has rendered.\n *\n * Overridden in subclasses.\n *\n * @param string $layoutFile The layout file that was rendered.\n * @return void\n */\n\tpublic function afterLayout($layoutFile) {\n\t}\n\n/**\n * Before render file callback.\n * Called before any view fragment is rendered.\n *\n * Overridden in subclasses.\n *\n * @param string $viewFile The file about to be rendered.\n * @return void\n */\n\tpublic function beforeRenderFile($viewfile) {\n\t}\n\n/**\n * After render file callback.\n * Called after any view fragment is rendered.\n *\n * Overridden in subclasses.\n *\n * @param string $viewFile The file just be rendered.\n * @param string $content The content that was rendered.\n * @return void\n */\n\tpublic function afterRenderFile($viewfile, $content) {\n\t}\n\n/**\n * Transforms a recordset from a hasAndBelongsToMany association to a list of selected\n * options for a multiple select element\n *\n * @param string|array $data\n * @param string $key\n * @return array\n */\n\tprotected function _selectedArray($data, $key = 'id') {\n\t\tif (!is_array($data)) {\n\t\t\t$model = $data;\n\t\t\tif (!empty($this->request->data[$model][$model])) {\n\t\t\t\treturn $this->request->data[$model][$model];\n\t\t\t}\n\t\t\tif (!empty($this->request->data[$model])) {\n\t\t\t\t$data = $this->request->data[$model];\n\t\t\t}\n\t\t}\n\t\t$array = array();\n\t\tif (!empty($data)) {\n\t\t\tforeach ($data as $row) {\n\t\t\t\tif (isset($row[$key])) {\n\t\t\t\t\t$array[$row[$key]] = $row[$key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn empty($array) ? null : $array;\n\t}\n\n/**\n * Resets the vars used by Helper::clean() to null\n *\n * @return void\n */\n\tprotected function _reset() {\n\t\t$this->_tainted = null;\n\t\t$this->_cleaned = null;\n\t}\n\n/**\n * Removes harmful content from output\n *\n * @return void\n */\n\tprotected function _clean() {\n\t\tif (get_magic_quotes_gpc()) {\n\t\t\t$this->_cleaned = stripslashes($this->_tainted);\n\t\t} else {\n\t\t\t$this->_cleaned = $this->_tainted;\n\t\t}\n\n\t\t$this->_cleaned = str_replace(array(\"&amp;\", \"&lt;\", \"&gt;\"), array(\"&amp;amp;\", \"&amp;lt;\", \"&amp;gt;\"), $this->_cleaned);\n\t\t$this->_cleaned = preg_replace('#(&\\#*\\w+)[\\x00-\\x20]+;#u', \"$1;\", $this->_cleaned);\n\t\t$this->_cleaned = preg_replace('#(&\\#x*)([0-9A-F]+);*#iu', \"$1$2;\", $this->_cleaned);\n\t\t$this->_cleaned = html_entity_decode($this->_cleaned, ENT_COMPAT, \"UTF-8\");\n\t\t$this->_cleaned = preg_replace('#(<[^>]+[\\x00-\\x20\\\"\\'\\/])(on|xmlns)[^>]*>#iUu', \"$1>\", $this->_cleaned);\n\t\t$this->_cleaned = preg_replace('#([a-z]*)[\\x00-\\x20]*=[\\x00-\\x20]*([\\`\\'\\\"]*)[\\\\x00-\\x20]*j[\\x00-\\x20]*a[\\x00-\\x20]*v[\\x00-\\x20]*a[\\x00-\\x20]*s[\\x00-\\x20]*c[\\x00-\\x20]*r[\\x00-\\x20]*i[\\x00-\\x20]*p[\\x00-\\x20]*t[\\x00-\\x20]*:#iUu', '$1=$2nojavascript...', $this->_cleaned);\n\t\t$this->_cleaned = preg_replace('#([a-z]*)[\\x00-\\x20]*=([\\'\\\"]*)[\\x00-\\x20]*v[\\x00-\\x20]*b[\\x00-\\x20]*s[\\x00-\\x20]*c[\\x00-\\x20]*r[\\x00-\\x20]*i[\\x00-\\x20]*p[\\x00-\\x20]*t[\\x00-\\x20]*:#iUu', '$1=$2novbscript...', $this->_cleaned);\n\t\t$this->_cleaned = preg_replace('#([a-z]*)[\\x00-\\x20]*=*([\\'\\\"]*)[\\x00-\\x20]*-moz-binding[\\x00-\\x20]*:#iUu', '$1=$2nomozbinding...', $this->_cleaned);\n\t\t$this->_cleaned = preg_replace('#([a-z]*)[\\x00-\\x20]*=([\\'\\\"]*)[\\x00-\\x20]*data[\\x00-\\x20]*:#Uu', '$1=$2nodata...', $this->_cleaned);\n\t\t$this->_cleaned = preg_replace('#(<[^>]+)style[\\x00-\\x20]*=[\\x00-\\x20]*([\\`\\'\\\"]*).*expression[\\x00-\\x20]*\\([^>]*>#iU', \"$1>\", $this->_cleaned);\n\t\t$this->_cleaned = preg_replace('#(<[^>]+)style[\\x00-\\x20]*=[\\x00-\\x20]*([\\`\\'\\\"]*).*behaviour[\\x00-\\x20]*\\([^>]*>#iU', \"$1>\", $this->_cleaned);\n\t\t$this->_cleaned = preg_replace('#(<[^>]+)style[\\x00-\\x20]*=[\\x00-\\x20]*([\\`\\'\\\"]*).*s[\\x00-\\x20]*c[\\x00-\\x20]*r[\\x00-\\x20]*i[\\x00-\\x20]*p[\\x00-\\x20]*t[\\x00-\\x20]*:*[^>]*>#iUu', \"$1>\", $this->_cleaned);\n\t\t$this->_cleaned = preg_replace('#</*\\w+:\\w[^>]*>#i', \"\", $this->_cleaned);\n\t\tdo {\n\t\t\t$oldstring = $this->_cleaned;\n\t\t\t$this->_cleaned = preg_replace('#</*(applet|meta|xml|blink|link|style|script|embed|object|iframe|frame|frameset|ilayer|layer|bgsound|title|base)[^>]*>#i', \"\", $this->_cleaned);\n\t\t} while ($oldstring !== $this->_cleaned);\n\t\t$this->_cleaned = str_replace(array(\"&amp;\", \"&lt;\", \"&gt;\"), array(\"&amp;amp;\", \"&amp;lt;\", \"&amp;gt;\"), $this->_cleaned);\n\t}\n\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":27416}]],"length":27416}
