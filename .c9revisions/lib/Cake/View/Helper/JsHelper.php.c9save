{"ts":1377222137672,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"<?php\n/**\n * Javascript Generator class file.\n *\n * PHP 5\n *\n * CakePHP :  Rapid Development Framework (http://cakephp.org)\n * Copyright (c) Cake Software Foundation, Inc. (http://cakefoundation.org)\n *\n * Licensed under The MIT License\n * For full copyright and license information, please see the LICENSE.txt\n * Redistributions of files must retain the above copyright notice.\n *\n * @copyright     Copyright (c) Cake Software Foundation, Inc. (http://cakefoundation.org)\n * @link          http://cakephp.org CakePHP(tm) Project\n * @package       Cake.View.Helper\n * @since         CakePHP(tm) v 1.2\n * @license       http://www.opensource.org/licenses/mit-license.php MIT License\n */\n\nApp::uses('AppHelper', 'View/Helper');\nApp::uses('JsBaseEngineHelper', 'View/Helper');\nApp::uses('Multibyte', 'I18n');\n\n/**\n * Javascript Generator helper class for easy use of JavaScript.\n *\n * JsHelper provides an abstract interface for authoring JavaScript with a\n * given client-side library.\n *\n * @package       Cake.View.Helper\n * @property      HtmlHelper $Html\n * @property      FormHelper $Form\n */\nclass JsHelper extends AppHelper {\n\n/**\n * Whether or not you want scripts to be buffered or output.\n *\n * @var boolean\n */\n\tpublic $bufferScripts = true;\n\n/**\n * Helper dependencies\n *\n * @var array\n */\n\tpublic $helpers = array('Html', 'Form');\n\n/**\n * Variables to pass to Javascript.\n *\n * @var array\n * @see JsHelper::set()\n */\n\tprotected $_jsVars = array();\n\n/**\n * Scripts that are queued for output\n *\n * @var array\n * @see JsHelper::buffer()\n */\n\tprotected $_bufferedScripts = array();\n\n/**\n * Current Javascript Engine that is being used\n *\n * @var string\n */\n\tprotected $_engineName;\n\n/**\n * The javascript variable created by set() variables.\n *\n * @var string\n */\n\tpublic $setVariable = 'app';\n\n/**\n * Constructor - determines engine helper\n *\n * @param View $View the view object the helper is attached to.\n * @param array $settings Settings array contains name of engine helper.\n */\n\tpublic function __construct(View $View, $settings = array()) {\n\t\t$className = 'Jquery';\n\t\tif (is_array($settings) && isset($settings[0])) {\n\t\t\t$className = $settings[0];\n\t\t} elseif (is_string($settings)) {\n\t\t\t$className = $settings;\n\t\t}\n\t\t$engineName = $className;\n\t\tlist(, $className) = pluginSplit($className);\n\n\t\t$this->_engineName = $className . 'Engine';\n\t\t$engineClass = $engineName . 'Engine';\n\t\t$this->helpers[] = $engineClass;\n\t\tparent::__construct($View, $settings);\n\t}\n\n/**\n * call__ Allows for dispatching of methods to the Engine Helper.\n * methods in the Engines bufferedMethods list will be automatically buffered.\n * You can control buffering with the buffer param as well. By setting the last parameter to\n * any engine method to a boolean you can force or disable buffering.\n *\n * e.g. `$js->get('#foo')->effect('fadeIn', array('speed' => 'slow'), true);`\n *\n * Will force buffering for the effect method. If the method takes an options array you may also add\n * a 'buffer' param to the options array and control buffering there as well.\n *\n * e.g. `$js->get('#foo')->event('click', $functionContents, array('buffer' => true));`\n *\n * The buffer parameter will not be passed onto the EngineHelper.\n *\n * @param string $method Method to be called\n * @param array $params Parameters for the method being called.\n * @return mixed Depends on the return of the dispatched method, or it could be an instance of the EngineHelper\n */\n\tpublic function __call($method, $params) {\n\t\tif ($this->{$this->_engineName} && method_exists($this->{$this->_engineName}, $method)) {\n\t\t\t$buffer = false;\n\t\t\t$engineHelper = $this->{$this->_engineName};\n\t\t\tif (in_array(strtolower($method), $engineHelper->bufferedMethods)) {\n\t\t\t\t$buffer = true;\n\t\t\t}\n\t\t\tif (count($params) > 0) {\n\t\t\t\t$lastParam = $params[count($params) - 1];\n\t\t\t\t$hasBufferParam = (is_bool($lastParam) || is_array($lastParam) && isset($lastParam['buffer']));\n\t\t\t\tif ($hasBufferParam && is_bool($lastParam)) {\n\t\t\t\t\t$buffer = $lastParam;\n\t\t\t\t\tunset($params[count($params) - 1]);\n\t\t\t\t} elseif ($hasBufferParam && is_array($lastParam)) {\n\t\t\t\t\t$buffer = $lastParam['buffer'];\n\t\t\t\t\tunset($params['buffer']);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$out = call_user_func_array(array(&$engineHelper, $method), $params);\n\t\t\tif ($this->bufferScripts && $buffer && is_string($out)) {\n\t\t\t\t$this->buffer($out);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (is_object($out) && $out instanceof JsBaseEngineHelper) {\n\t\t\t\treturn $this;\n\t\t\t}\n\t\t\treturn $out;\n\t\t}\n\t\tif (method_exists($this, $method . '_')) {\n\t\t\treturn call_user_func(array(&$this, $method . '_'), $params);\n\t\t}\n\t\ttrigger_error(__d('cake_dev', 'JsHelper:: Missing Method %s is undefined', $method), E_USER_WARNING);\n\t}\n\n/**\n * Overwrite inherited Helper::value()\n * See JsBaseEngineHelper::value() for more information on this method.\n *\n * @param mixed $val A PHP variable to be converted to JSON\n * @param boolean $quoteString If false, leaves string values unquoted\n * @return string a JavaScript-safe/JSON representation of $val\n * @link http://book.cakephp.org/2.0/en/core-libraries/helpers/js.html#JsHelper::value\n */\n\tpublic function value($val = array(), $quoteString = null, $key = 'value') {\n\t\tif ($quoteString === null) {\n\t\t\t$quoteString = true;\n\t\t}\n\t\treturn $this->{$this->_engineName}->value($val, $quoteString);\n\t}\n\n/**\n * Writes all Javascript generated so far to a code block or\n * caches them to a file and returns a linked script. If no scripts have been\n * buffered this method will return null. If the request is an XHR(ajax) request\n * onDomReady will be set to false. As the dom is already 'ready'.\n *\n * ### Options\n *\n * - `inline` - Set to true to have scripts output as a script block inline\n *   if `cache` is also true, a script link tag will be generated. (default true)\n * - `cache` - Set to true to have scripts cached to a file and linked in (default false)\n * - `clear` - Set to false to prevent script cache from being cleared (default true)\n * - `onDomReady` - wrap cached scripts in domready event (default true)\n * - `safe` - if an inline block is generated should it be wrapped in <![CDATA[ ... ]]> (default true)\n *\n * @param array $options options for the code block\n * @return mixed Completed javascript tag if there are scripts, if there are no buffered\n *   scripts null will be returned.\n * @link http://book.cakephp.org/2.0/en/core-libraries/helpers/js.html#JsHelper::writeBuffer\n */\n\tpublic function writeBuffer($options = array()) {\n\t\t$domReady = !$this->request->is('ajax');\n\t\t$defaults = array(\n\t\t\t'onDomReady' => $domReady, 'inline' => true,\n\t\t\t'cache' => false, 'clear' => true, 'safe' => true\n\t\t);\n\t\t$options = array_merge($defaults, $options);\n\t\t$script = implode(\"\\n\", $this->getBuffer($options['clear']));\n\n\t\tif (empty($script)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ($options['onDomReady']) {\n\t\t\t$script = $this->{$this->_engineName}->domReady($script);\n\t\t}\n\t\t$opts = $options;\n\t\tunset($opts['onDomReady'], $opts['cache'], $opts['clear']);\n\n\t\tif ($options['cache'] && $options['inline']) {\n\t\t\t$filename = md5($script);\n\t\t\tif (file_exists(JS . $filename . '.js')\n\t\t\t\t|| cache(str_replace(WWW_ROOT, '', JS) . $filename . '.js', $script, '+999 days', 'public')\n\t\t\t\t) {\n\t\t\t\treturn $this->Html->script($filename);\n\t\t\t}\n\t\t}\n\n\t\t$return = $this->Html->scriptBlock($script, $opts);\n\t\tif ($options['inline']) {\n\t\t\treturn $return;\n\t\t}\n\t\treturn null;\n\t}\n\n/**\n * Write a script to the buffered scripts.\n *\n * @param string $script Script string to add to the buffer.\n * @param boolean $top If true the script will be added to the top of the\n *   buffered scripts array. If false the bottom.\n * @return void\n * @link http://book.cakephp.org/2.0/en/core-libraries/helpers/js.html#JsHelper::buffer\n */\n\tpublic function buffer($script, $top = false) {\n\t\tif ($top) {\n\t\t\tarray_unshift($this->_bufferedScripts, $script);\n\t\t} else {\n\t\t\t$this->_bufferedScripts[] = $script;\n\t\t}\n\t}\n\n/**\n * Get all the buffered scripts\n *\n * @param boolean $clear Whether or not to clear the script caches (default true)\n * @return array Array of scripts added to the request.\n * @link http://book.cakephp.org/2.0/en/core-libraries/helpers/js.html#JsHelper::getBuffer\n */\n\tpublic function getBuffer($clear = true) {\n\t\t$this->_createVars();\n\t\t$scripts = $this->_bufferedScripts;\n\t\tif ($clear) {\n\t\t\t$this->_bufferedScripts = array();\n\t\t\t$this->_jsVars = array();\n\t\t}\n\t\treturn $scripts;\n\t}\n\n/**\n * Generates the object string for variables passed to javascript and adds to buffer\n *\n * @return void\n */\n\tprotected function _createVars() {\n\t\tif (!empty($this->_jsVars)) {\n\t\t\t$setVar = (strpos($this->setVariable, '.')) ? $this->setVariable : 'window.' . $this->setVariable;\n\t\t\t$this->buffer($setVar . ' = ' . $this->object($this->_jsVars) . ';', true);\n\t\t}\n\t}\n\n/**\n * Generate an 'Ajax' link. Uses the selected JS engine to create a link\n * element that is enhanced with Javascript. Options can include\n * both those for HtmlHelper::link() and JsBaseEngine::request(), JsBaseEngine::event();\n *\n * ### Options\n *\n * - `confirm` - Generate a confirm() dialog before sending the event.\n * - `id` - use a custom id.\n * - `htmlAttributes` - additional non-standard htmlAttributes. Standard attributes are class, id,\n *    rel, title, escape, onblur and onfocus.\n * - `buffer` - Disable the buffering and return a script tag in addition to the link.\n *\n * @param string $title Title for the link.\n * @param string|array $url Mixed either a string URL or a CakePHP URL array.\n * @param array $options Options for both the HTML element and Js::request()\n * @return string Completed link. If buffering is disabled a script tag will be returned as well.\n * @link http://book.cakephp.org/2.0/en/core-libraries/helpers/js.html#JsHelper::link\n */\n\tpublic function link($title, $url = null, $options = array()) {\n\t\tif (!isset($options['id'])) {\n\t\t\t$options['id'] = 'link-' . intval(mt_rand());\n\t\t}\n\t\tlist($options, $htmlOptions) = $this->_getHtmlOptions($options);\n\t\t$out = $this->Html->link($title, $url, $htmlOptions);\n\t\t$this->get('#' . $htmlOptions['id']);\n\t\t$requestString = $event = '';\n\t\tif (isset($options['confirm'])) {\n\t\t\t$requestString = $this->confirmReturn($options['confirm']);\n\t\t\tunset($options['confirm']);\n\t\t}\n\t\t$buffer = isset($options['buffer']) ? $options['buffer'] : null;\n\t\t$safe = isset($options['safe']) ? $options['safe'] : true;\n\t\tunset($options['buffer'], $options['safe']);\n\n\t\t$requestString .= $this->request($url, $options);\n\n\t\tif (!empty($requestString)) {\n\t\t\t$event = $this->event('click', $requestString, $options + array('buffer' => $buffer));\n\t\t}\n\t\tif (isset($buffer) && !$buffer) {\n\t\t\t$opts = array('safe' => $safe);\n\t\t\t$out .= $this->Html->scriptBlock($event, $opts);\n\t\t}\n\t\treturn $out;\n\t}\n\n/**\n * Pass variables into Javascript. Allows you to set variables that will be\n * output when the buffer is fetched with `JsHelper::getBuffer()` or `JsHelper::writeBuffer()`\n * The Javascript variable used to output set variables can be controlled with `JsHelper::$setVariable`\n *\n * @param string|array $one Either an array of variables to set, or the name of the variable to set.\n * @param string|array $two If $one is a string, $two is the value for that key.\n * @return void\n * @link http://book.cakephp.org/2.0/en/core-libraries/helpers/js.html#JsHelper::set\n */\n\tpublic function set($one, $two = null) {\n\t\t$data = null;\n\t\tif (is_array($one)) {\n\t\t\tif (is_array($two)) {\n\t\t\t\t$data = array_combine($one, $two);\n\t\t\t} else {\n\t\t\t\t$data = $one;\n\t\t\t}\n\t\t} else {\n\t\t\t$data = array($one => $two);\n\t\t}\n\t\tif (!$data) {\n\t\t\treturn false;\n\t\t}\n\t\t$this->_jsVars = array_merge($this->_jsVars, $data);\n\t}\n\n/**\n * Uses the selected JS engine to create a submit input\n * element that is enhanced with Javascript. Options can include\n * both those for FormHelper::submit() and JsBaseEngine::request(), JsBaseEngine::event();\n *\n * Forms submitting with this method, cannot send files. Files do not transfer over XmlHttpRequest\n * and require an iframe or flash.\n *\n * ### Options\n *\n * - `url` The url you wish the XHR request to submit to.\n * - `confirm` A string to use for a confirm() message prior to submitting the request.\n * - `method` The method you wish the form to send by, defaults to POST\n * - `buffer` Whether or not you wish the script code to be buffered, defaults to true.\n * - Also see options for JsHelper::request() and JsHelper::event()\n *\n * @param string $caption The display text of the submit button.\n * @param array $options Array of options to use. See the options for the above mentioned methods.\n * @return string Completed submit button.\n * @link http://book.cakephp.org/2.0/en/core-libraries/helpers/js.html#JsHelper::submit\n */\n\tpublic function submit($caption = null, $options = array()) {\n\t\tif (!isset($options['id'])) {\n\t\t\t$options['id'] = 'submit-' . intval(mt_rand());\n\t\t}\n\t\t$formOptions = array('div');\n\t\tlist($options, $htmlOptions) = $this->_getHtmlOptions($options, $formOptions);\n\t\t$out = $this->Form->submit($caption, $htmlOptions);\n\n\t\t$this->get('#' . $htmlOptions['id']);\n\n\t\t$options['data'] = $this->serializeForm(array('isForm' => false, 'inline' => true));\n\t\t$requestString = $url = '';\n\t\tif (isset($options['confirm'])) {\n\t\t\t$requestString = $this->confirmReturn($options['confirm']);\n\t\t\tunset($options['confirm']);\n\t\t}\n\t\tif (isset($options['url'])) {\n\t\t\t$url = $options['url'];\n\t\t\tunset($options['url']);\n\t\t}\n\t\tif (!isset($options['method'])) {\n\t\t\t$options['method'] = 'post';\n\t\t}\n\t\t$options['dataExpression'] = true;\n\n\t\t$buffer = isset($options['buffer']) ? $options['buffer'] : null;\n\t\t$safe = isset($options['safe']) ? $options['safe'] : true;\n\t\tunset($options['buffer'], $options['safe']);\n\n\t\t$requestString .= $this->request($url, $options);\n\t\tif (!empty($requestString)) {\n\t\t\t$event = $this->event('click', $requestString, $options + array('buffer' => $buffer));\n\t\t}\n\t\tif (isset($buffer) && !$buffer) {\n\t\t\t$opts = array('safe' => $safe);\n\t\t\t$out .= $this->Html->scriptBlock($event, $opts);\n\t\t}\n\t\treturn $out;\n\t}\n\n/**\n * Parse a set of Options and extract the Html options.\n * Extracted Html Options are removed from the $options param.\n *\n * @param array $options Options to filter.\n * @param array $additional Array of additional keys to extract and include in the return options array.\n * @return array Array of js options and Htmloptions\n */\n\tprotected function _getHtmlOptions($options, $additional = array()) {\n\t\t$htmlKeys = array_merge(\n\t\t\tarray('class', 'id', 'escape', 'onblur', 'onfocus', 'rel', 'title', 'style'),\n\t\t\t$additional\n\t\t);\n\t\t$htmlOptions = array();\n\t\tforeach ($htmlKeys as $key) {\n\t\t\tif (isset($options[$key])) {\n\t\t\t\t$htmlOptions[$key] = $options[$key];\n\t\t\t}\n\t\t\tunset($options[$key]);\n\t\t}\n\t\tif (isset($options['htmlAttributes'])) {\n\t\t\t$htmlOptions = array_merge($htmlOptions, $options['htmlAttributes']);\n\t\t\tunset($options['htmlAttributes']);\n\t\t}\n\t\treturn array($options, $htmlOptions);\n\t}\n\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":14829}]],"length":14829}
