{"ts":1377217910810,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"<?php\n/**\n * Object-relational mapper.\n *\n * DBO-backed object data model, for mapping database tables to Cake objects.\n *\n * PHP 5\n *\n * CakePHP(tm) : Rapid Development Framework (http://cakephp.org)\n * Copyright (c) Cake Software Foundation, Inc. (http://cakefoundation.org)\n *\n * Licensed under The MIT License\n * For full copyright and license information, please see the LICENSE.txt\n * Redistributions of files must retain the above copyright notice.\n *\n * @copyright     Copyright (c) Cake Software Foundation, Inc. (http://cakefoundation.org)\n * @link          http://cakephp.org CakePHP(tm) Project\n * @package       Cake.Model\n * @since         CakePHP(tm) v 0.10.0.0\n * @license       http://www.opensource.org/licenses/mit-license.php MIT License\n */\n\nApp::uses('ClassRegistry', 'Utility');\nApp::uses('Validation', 'Utility');\nApp::uses('String', 'Utility');\nApp::uses('Hash', 'Utility');\nApp::uses('BehaviorCollection', 'Model');\nApp::uses('ModelBehavior', 'Model');\nApp::uses('ModelValidator', 'Model');\nApp::uses('ConnectionManager', 'Model');\nApp::uses('Xml', 'Utility');\nApp::uses('CakeEvent', 'Event');\nApp::uses('CakeEventListener', 'Event');\nApp::uses('CakeEventManager', 'Event');\n\n/**\n * Object-relational mapper.\n *\n * DBO-backed object data model.\n * Automatically selects a database table name based on a pluralized lowercase object class name\n * (i.e. class 'User' => table 'users'; class 'Man' => table 'men')\n * The table is required to have at least 'id auto_increment' primary key.\n *\n * @package       Cake.Model\n * @link          http://book.cakephp.org/2.0/en/models.html\n */\nclass Model extends Object implements CakeEventListener {\n\n/**\n * The name of the DataSource connection that this Model uses\n *\n * The value must be an attribute name that you defined in `app/Config/database.php`\n * or created using `ConnectionManager::create()`.\n *\n * @var string\n * @link http://book.cakephp.org/2.0/en/models/model-attributes.html#usedbconfig\n */\n\tpublic $useDbConfig = 'default';\n\n/**\n * Custom database table name, or null/false if no table association is desired.\n *\n * @var string\n * @link http://book.cakephp.org/2.0/en/models/model-attributes.html#usetable\n */\n\tpublic $useTable = null;\n\n/**\n * Custom display field name. Display fields are used by Scaffold, in SELECT boxes' OPTION elements.\n *\n * This field is also used in `find('list')` when called with no extra parameters in the fields list\n *\n * @var string\n * @link http://book.cakephp.org/2.0/en/models/model-attributes.html#displayfield\n */\n\tpublic $displayField = null;\n\n/**\n * Value of the primary key ID of the record that this model is currently pointing to.\n * Automatically set after database insertions.\n *\n * @var mixed\n */\n\tpublic $id = false;\n\n/**\n * Container for the data that this model gets from persistent storage (usually, a database).\n *\n * @var array\n * @link http://book.cakephp.org/2.0/en/models/model-attributes.html#data\n */\n\tpublic $data = array();\n\n/**\n * Holds physical schema/database name for this model. Automatically set during Model creation.\n *\n * @var string\n */\n\tpublic $schemaName = null;\n\n/**\n * Table name for this Model.\n *\n * @var string\n */\n\tpublic $table = false;\n\n/**\n * The name of the primary key field for this model.\n *\n * @var string\n * @link http://book.cakephp.org/2.0/en/models/model-attributes.html#primaryKey\n */\n\tpublic $primaryKey = null;\n\n/**\n * Field-by-field table metadata.\n *\n * @var array\n */\n\tprotected $_schema = null;\n\n/**\n * List of validation rules. It must be an array with the field name as key and using\n * as value one of the following possibilities\n *\n * ### Validating using regular expressions\n *\n * {{{\n * public $validate = array(\n *     'name' => '/^[a-z].+$/i'\n * );\n * }}}\n *\n * ### Validating using methods (no parameters)\n *\n * {{{\n * public $validate = array(\n *     'name' => 'notEmpty'\n * );\n * }}}\n *\n * ### Validating using methods (with parameters)\n *\n * {{{\n * public $validate = array(\n *     'age' => array(\n *         'rule' => array('between', 5, 25)\n *     )\n * );\n * }}}\n *\n * ### Validating using custom method\n *\n * {{{\n * public $validate = array(\n *     'password' => array(\n *         'rule' => array('customValidation')\n *     )\n * );\n * public function customValidation($data) {\n *     // $data will contain array('password' => 'value')\n *     if (isset($this->data[$this->alias]['password2'])) {\n *         return $this->data[$this->alias]['password2'] === current($data);\n *     }\n *     return true;\n * }\n * }}}\n *\n * ### Validations with messages\n *\n * The messages will be used in Model::$validationErrors and can be used in the FormHelper\n *\n * {{{\n * public $validate = array(\n *     'age' => array(\n *         'rule' => array('between', 5, 25),\n *         'message' => array('The age must be between %d and %d.')\n *     )\n * );\n * }}}\n *\n * ### Multiple validations to the same field\n *\n * {{{\n * public $validate = array(\n *     'login' => array(\n *         array(\n *             'rule' => 'alphaNumeric',\n *             'message' => 'Only alphabets and numbers allowed',\n *             'last' => true\n *         ),\n *         array(\n *             'rule' => array('minLength', 8),\n *             'message' => array('Minimum length of %d characters')\n *         )\n *     )\n * );\n * }}}\n *\n * ### Valid keys in validations\n *\n * - `rule`: String with method name, regular expression (started by slash) or array with method and parameters\n * - `message`: String with the message or array if have multiple parameters. See http://php.net/sprintf\n * - `last`: Boolean value to indicate if continue validating the others rules if the current fail [Default: true]\n * - `required`: Boolean value to indicate if the field must be present on save\n * - `allowEmpty`: Boolean value to indicate if the field can be empty\n * - `on`: Possible values: `update`, `create`. Indicate to apply this rule only on update or create\n *\n * @var array\n * @link http://book.cakephp.org/2.0/en/models/model-attributes.html#validate\n * @link http://book.cakephp.org/2.0/en/models/data-validation.html\n */\n\tpublic $validate = array();\n\n/**\n * List of validation errors.\n *\n * @var array\n */\n\tpublic $validationErrors = array();\n\n/**\n * Name of the validation string domain to use when translating validation errors.\n *\n * @var string\n */\n\tpublic $validationDomain = null;\n\n/**\n * Database table prefix for tables in model.\n *\n * @var string\n * @link http://book.cakephp.org/2.0/en/models/model-attributes.html#tableprefix\n */\n\tpublic $tablePrefix = null;\n\n/**\n * Plugin model belongs to.\n *\n * @var string\n */\n\tpublic $plugin = null;\n\n/**\n * Name of the model.\n *\n * @var string\n * @link http://book.cakephp.org/2.0/en/models/model-attributes.html#name\n */\n\tpublic $name = null;\n\n/**\n * Alias name for model.\n *\n * @var string\n */\n\tpublic $alias = null;\n\n/**\n * List of table names included in the model description. Used for associations.\n *\n * @var array\n */\n\tpublic $tableToModel = array();\n\n/**\n * Whether or not to cache queries for this model. This enables in-memory\n * caching only, the results are not stored beyond the current request.\n *\n * @var boolean\n * @link http://book.cakephp.org/2.0/en/models/model-attributes.html#cachequeries\n */\n\tpublic $cacheQueries = false;\n\n/**\n * Detailed list of belongsTo associations.\n *\n * ### Basic usage\n *\n * `public $belongsTo = array('Group', 'Department');`\n *\n * ### Detailed configuration\n *\n * {{{\n * public $belongsTo = array(\n *     'Group',\n *     'Department' => array(\n *         'className' => 'Department',\n *         'foreignKey' => 'department_id'\n *     )\n * );\n * }}}\n *\n * ### Possible keys in association\n *\n * - `className`: the classname of the model being associated to the current model.\n *   If you're defining a 'Profile belongsTo User' relationship, the className key should equal 'User.'\n * - `foreignKey`: the name of the foreign key found in the current model. This is\n *   especially handy if you need to define multiple belongsTo relationships. The default\n *   value for this key is the underscored, singular name of the other model, suffixed with '_id'.\n * - `conditions`: An SQL fragment used to filter related model records. It's good\n *   practice to use model names in SQL fragments: 'User.active = 1' is always\n *   better than just 'active = 1.'\n * - `type`: the type of the join to use in the SQL query, default is LEFT which\n *   may not fit your needs in all situations, INNER may be helpful when you want\n *   everything from your main and associated models or nothing at all!(effective\n *   when used with some conditions of course). (NB: type value is in lower case - i.e. left, inner)\n * - `fields`: A list of fields to be retrieved when the associated model data is\n *   fetched. Returns all fields by default.\n * - `order`: An SQL fragment that defines the sorting order for the returned associated rows.\n * - `counterCache`: If set to true the associated Model will automatically increase or\n *   decrease the \"[singular_model_name]_count\" field in the foreign table whenever you do\n *   a save() or delete(). If its a string then its the field name to use. The value in the\n *   counter field represents the number of related rows.\n * - `counterScope`: Optional conditions array to use for updating counter cache field.\n *\n * @var array\n * @link http://book.cakephp.org/2.0/en/models/associations-linking-models-together.html#belongsto\n */\n\tpublic $belongsTo = array();\n\n/**\n * Detailed list of hasOne associations.\n *\n * ### Basic usage\n *\n * `public $hasOne = array('Profile', 'Address');`\n *\n * ### Detailed configuration\n *\n * {{{\n * public $hasOne = array(\n *     'Profile',\n *     'Address' => array(\n *         'className' => 'Address',\n *         'foreignKey' => 'user_id'\n *     )\n * );\n * }}}\n *\n * ### Possible keys in association\n *\n * - `className`: the classname of the model being associated to the current model.\n *   If you're defining a 'User hasOne Profile' relationship, the className key should equal 'Profile.'\n * - `foreignKey`: the name of the foreign key found in the other model. This is\n *   especially handy if you need to define multiple hasOne relationships.\n *   The default value for this key is the underscored, singular name of the\n *   current model, suffixed with '_id'. In the example above it would default to 'user_id'.\n * - `conditions`: An SQL fragment used to filter related model records. It's good\n *   practice to use model names in SQL fragments: \"Profile.approved = 1\" is\n *   always better than just \"approved = 1.\"\n * - `fields`: A list of fields to be retrieved when the associated model data is\n *   fetched. Returns all fields by default.\n * - `order`: An SQL fragment that defines the sorting order for the returned associated rows.\n * - `dependent`: When the dependent key is set to true, and the model's delete()\n *   method is called with the cascade parameter set to true, associated model\n *   records are also deleted. In this case we set it true so that deleting a\n *   User will also delete her associated Profile.\n *\n * @var array\n * @link http://book.cakephp.org/2.0/en/models/associations-linking-models-together.html#hasone\n */\n\tpublic $hasOne = array();\n\n/**\n * Detailed list of hasMany associations.\n *\n * ### Basic usage\n *\n * `public $hasMany = array('Comment', 'Task');`\n *\n * ### Detailed configuration\n *\n * {{{\n * public $hasMany = array(\n *     'Comment',\n *     'Task' => array(\n *         'className' => 'Task',\n *         'foreignKey' => 'user_id'\n *     )\n * );\n * }}}\n *\n * ### Possible keys in association\n *\n * - `className`: the classname of the model being associated to the current model.\n *   If you're defining a 'User hasMany Comment' relationship, the className key should equal 'Comment.'\n * - `foreignKey`: the name of the foreign key found in the other model. This is\n *   especially handy if you need to define multiple hasMany relationships. The default\n *   value for this key is the underscored, singular name of the actual model, suffixed with '_id'.\n * - `conditions`: An SQL fragment used to filter related model records. It's good\n *   practice to use model names in SQL fragments: \"Comment.status = 1\" is always\n *   better than just \"status = 1.\"\n * - `fields`: A list of fields to be retrieved when the associated model data is\n *   fetched. Returns all fields by default.\n * - `order`: An SQL fragment that defines the sorting order for the returned associated rows.\n * - `limit`: The maximum number of associated rows you want returned.\n * - `offset`: The number of associated rows to skip over (given the current\n *   conditions and order) before fetching and associating.\n * - `dependent`: When dependent is set to true, recursive model deletion is\n *   possible. In this example, Comment records will be deleted when their\n *   associated User record has been deleted.\n * - `exclusive`: When exclusive is set to true, recursive model deletion does\n *   the delete with a deleteAll() call, instead of deleting each entity separately.\n *   This greatly improves performance, but may not be ideal for all circumstances.\n * - `finderQuery`: A complete SQL query CakePHP can use to fetch associated model\n *   records. This should be used in situations that require very custom results.\n *\n * @var array\n * @link http://book.cakephp.org/2.0/en/models/associations-linking-models-together.html#hasmany\n */\n\tpublic $hasMany = array();\n\n/**\n * Detailed list of hasAndBelongsToMany associations.\n *\n * ### Basic usage\n *\n * `public $hasAndBelongsToMany = array('Role', 'Address');`\n *\n * ### Detailed configuration\n *\n * {{{\n * public $hasAndBelongsToMany = array(\n *     'Role',\n *     'Address' => array(\n *         'className' => 'Address',\n *         'foreignKey' => 'user_id',\n *         'associationForeignKey' => 'address_id',\n *         'joinTable' => 'addresses_users'\n *     )\n * );\n * }}}\n *\n * ### Possible keys in association\n *\n * - `className`: the classname of the model being associated to the current model.\n *   If you're defining a 'Recipe HABTM Tag' relationship, the className key should equal 'Tag.'\n * - `joinTable`: The name of the join table used in this association (if the\n *   current table doesn't adhere to the naming convention for HABTM join tables).\n * - `with`: Defines the name of the model for the join table. By default CakePHP\n *   will auto-create a model for you. Using the example above it would be called\n *   RecipesTag. By using this key you can override this default name. The join\n *   table model can be used just like any \"regular\" model to access the join table directly.\n * - `foreignKey`: the name of the foreign key found in the current model.\n *   This is especially handy if you need to define multiple HABTM relationships.\n *   The default value for this key is the underscored, singular name of the\n *   current model, suffixed with '_id'.\n * - `associationForeignKey`: the name of the foreign key found in the other model.\n *   This is especially handy if you need to define multiple HABTM relationships.\n *   The default value for this key is the underscored, singular name of the other\n *   model, suffixed with '_id'.\n * - `unique`: If true (default value) cake will first delete existing relationship\n *   records in the foreign keys table before inserting new ones, when updating a\n *   record. So existing associations need to be passed again when updating.\n *   To prevent deletion of existing relationship records, set this key to a string 'keepExisting'.\n * - `conditions`: An SQL fragment used to filter related model records. It's good\n *   practice to use model names in SQL fragments: \"Comment.status = 1\" is always\n *   better than just \"status = 1.\"\n * - `fields`: A list of fields to be retrieved when the associated model data is\n *   fetched. Returns all fields by default.\n * - `order`: An SQL fragment that defines the sorting order for the returned associated rows.\n * - `limit`: The maximum number of associated rows you want returned.\n * - `offset`: The number of associated rows to skip over (given the current\n *   conditions and order) before fetching and associating.\n * - `finderQuery`, `deleteQuery`, `insertQuery`: A complete SQL query CakePHP\n *   can use to fetch, delete, or create new associated model records. This should\n *   be used in situations that require very custom results.\n *\n * @var array\n * @link http://book.cakephp.org/2.0/en/models/associations-linking-models-together.html#hasandbelongstomany-habtm\n */\n\tpublic $hasAndBelongsToMany = array();\n\n/**\n * List of behaviors to load when the model object is initialized. Settings can be\n * passed to behaviors by using the behavior name as index. Eg:\n *\n * public $actsAs = array('Translate', 'MyBehavior' => array('setting1' => 'value1'))\n *\n * @var array\n * @link http://book.cakephp.org/2.0/en/models/behaviors.html#using-behaviors\n */\n\tpublic $actsAs = null;\n\n/**\n * Holds the Behavior objects currently bound to this model.\n *\n * @var BehaviorCollection\n */\n\tpublic $Behaviors = null;\n\n/**\n * Whitelist of fields allowed to be saved.\n *\n * @var array\n */\n\tpublic $whitelist = array();\n\n/**\n * Whether or not to cache sources for this model.\n *\n * @var boolean\n */\n\tpublic $cacheSources = true;\n\n/**\n * Type of find query currently executing.\n *\n * @var string\n */\n\tpublic $findQueryType = null;\n\n/**\n * Number of associations to recurse through during find calls. Fetches only\n * the first level by default.\n *\n * @var integer\n * @link http://book.cakephp.org/2.0/en/models/model-attributes.html#recursive\n */\n\tpublic $recursive = 1;\n\n/**\n * The column name(s) and direction(s) to order find results by default.\n *\n * public $order = \"Post.created DESC\";\n * public $order = array(\"Post.view_count DESC\", \"Post.rating DESC\");\n *\n * @var string\n * @link http://book.cakephp.org/2.0/en/models/model-attributes.html#order\n */\n\tpublic $order = null;\n\n/**\n * Array of virtual fields this model has. Virtual fields are aliased\n * SQL expressions. Fields added to this property will be read as other fields in a model\n * but will not be saveable.\n *\n * `public $virtualFields = array('two' => '1 + 1');`\n *\n * Is a simplistic example of how to set virtualFields\n *\n * @var array\n * @link http://book.cakephp.org/2.0/en/models/model-attributes.html#virtualfields\n */\n\tpublic $virtualFields = array();\n\n/**\n * Default list of association keys.\n *\n * @var array\n */\n\tprotected $_associationKeys = array(\n\t\t'belongsTo' => array('className', 'foreignKey', 'conditions', 'fields', 'order', 'counterCache'),\n\t\t'hasOne' => array('className', 'foreignKey', 'conditions', 'fields', 'order', 'dependent'),\n\t\t'hasMany' => array('className', 'foreignKey', 'conditions', 'fields', 'order', 'limit', 'offset', 'dependent', 'exclusive', 'finderQuery', 'counterQuery'),\n\t\t'hasAndBelongsToMany' => array('className', 'joinTable', 'with', 'foreignKey', 'associationForeignKey', 'conditions', 'fields', 'order', 'limit', 'offset', 'unique', 'finderQuery', 'deleteQuery', 'insertQuery')\n\t);\n\n/**\n * Holds provided/generated association key names and other data for all associations.\n *\n * @var array\n */\n\tprotected $_associations = array('belongsTo', 'hasOne', 'hasMany', 'hasAndBelongsToMany');\n\n// @codingStandardsIgnoreStart\n\n/**\n * Holds model associations temporarily to allow for dynamic (un)binding.\n *\n * @var array\n */\n\tpublic $__backAssociation = array();\n\n/**\n * Back inner association\n *\n * @var array\n */\n\tpublic $__backInnerAssociation = array();\n\n/**\n * Back original association\n *\n * @var array\n */\n\tpublic $__backOriginalAssociation = array();\n\n/**\n * Back containable association\n *\n * @var array\n */\n\tpublic $__backContainableAssociation = array();\n\n// @codingStandardsIgnoreEnd\n\n/**\n * The ID of the model record that was last inserted.\n *\n * @var integer\n */\n\tprotected $_insertID = null;\n\n/**\n * Has the datasource been configured.\n *\n * @var boolean\n * @see Model::getDataSource\n */\n\tprotected $_sourceConfigured = false;\n\n/**\n * List of valid finder method options, supplied as the first parameter to find().\n *\n * @var array\n */\n\tpublic $findMethods = array(\n\t\t'all' => true, 'first' => true, 'count' => true,\n\t\t'neighbors' => true, 'list' => true, 'threaded' => true\n\t);\n\n/**\n * Instance of the CakeEventManager this model is using\n * to dispatch inner events.\n *\n * @var CakeEventManager\n */\n\tprotected $_eventManager = null;\n\n/**\n * Instance of the ModelValidator\n *\n * @var ModelValidator\n */\n\tprotected $_validator = null;\n\n/**\n * Constructor. Binds the model's database table to the object.\n *\n * If `$id` is an array it can be used to pass several options into the model.\n *\n * - `id`: The id to start the model on.\n * - `table`: The table to use for this model.\n * - `ds`: The connection name this model is connected to.\n * - `name`: The name of the model eg. Post.\n * - `alias`: The alias of the model, this is used for registering the instance in the `ClassRegistry`.\n *   eg. `ParentThread`\n *\n * ### Overriding Model's __construct method.\n *\n * When overriding Model::__construct() be careful to include and pass in all 3 of the\n * arguments to `parent::__construct($id, $table, $ds);`\n *\n * ### Dynamically creating models\n *\n * You can dynamically create model instances using the $id array syntax.\n *\n * {{{\n * $Post = new Model(array('table' => 'posts', 'name' => 'Post', 'ds' => 'connection2'));\n * }}}\n *\n * Would create a model attached to the posts table on connection2. Dynamic model creation is useful\n * when you want a model object that contains no associations or attached behaviors.\n *\n * @param integer|string|array $id Set this ID for this model on startup, can also be an array of options, see above.\n * @param string $table Name of database table to use.\n * @param string $ds DataSource connection name.\n */\n\tpublic function __construct($id = false, $table = null, $ds = null) {\n\t\tparent::__construct();\n\n\t\tif (is_array($id)) {\n\t\t\textract(array_merge(\n\t\t\t\tarray(\n\t\t\t\t\t'id' => $this->id, 'table' => $this->useTable, 'ds' => $this->useDbConfig,\n\t\t\t\t\t'name' => $this->name, 'alias' => $this->alias, 'plugin' => $this->plugin\n\t\t\t\t),\n\t\t\t\t$id\n\t\t\t));\n\t\t}\n\n\t\tif ($this->plugin === null) {\n\t\t\t$this->plugin = (isset($plugin) ? $plugin : $this->plugin);\n\t\t}\n\n\t\tif ($this->name === null) {\n\t\t\t$this->name = (isset($name) ? $name : get_class($this));\n\t\t}\n\n\t\tif ($this->alias === null) {\n\t\t\t$this->alias = (isset($alias) ? $alias : $this->name);\n\t\t}\n\n\t\tif ($this->primaryKey === null) {\n\t\t\t$this->primaryKey = 'id';\n\t\t}\n\n\t\tClassRegistry::addObject($this->alias, $this);\n\n\t\t$this->id = $id;\n\t\tunset($id);\n\n\t\tif ($table === false) {\n\t\t\t$this->useTable = false;\n\t\t} elseif ($table) {\n\t\t\t$this->useTable = $table;\n\t\t}\n\n\t\tif ($ds !== null) {\n\t\t\t$this->useDbConfig = $ds;\n\t\t}\n\n\t\tif (is_subclass_of($this, 'AppModel')) {\n\t\t\t$merge = array('actsAs', 'findMethods');\n\t\t\t$parentClass = get_parent_class($this);\n\t\t\tif ($parentClass !== 'AppModel') {\n\t\t\t\t$this->_mergeVars($merge, $parentClass);\n\t\t\t}\n\t\t\t$this->_mergeVars($merge, 'AppModel');\n\t\t}\n\t\t$this->_mergeVars(array('findMethods'), 'Model');\n\n\t\t$this->Behaviors = new BehaviorCollection();\n\n\t\tif ($this->useTable !== false) {\n\n\t\t\tif ($this->useTable === null) {\n\t\t\t\t$this->useTable = Inflector::tableize($this->name);\n\t\t\t}\n\n\t\t\tif (!$this->displayField) {\n\t\t\t\tunset($this->displayField);\n\t\t\t}\n\t\t\t$this->table = $this->useTable;\n\t\t\t$this->tableToModel[$this->table] = $this->alias;\n\t\t} elseif ($this->table === false) {\n\t\t\t$this->table = Inflector::tableize($this->name);\n\t\t}\n\n\t\tif ($this->tablePrefix === null) {\n\t\t\tunset($this->tablePrefix);\n\t\t}\n\n\t\t$this->_createLinks();\n\t\t$this->Behaviors->init($this->alias, $this->actsAs);\n\t}\n\n/**\n * Returns a list of all events that will fire in the model during it's lifecycle.\n * You can override this function to add you own listener callbacks\n *\n * @return array\n */\n\tpublic function implementedEvents() {\n\t\treturn array(\n\t\t\t'Model.beforeFind' => array('callable' => 'beforeFind', 'passParams' => true),\n\t\t\t'Model.afterFind' => array('callable' => 'afterFind', 'passParams' => true),\n\t\t\t'Model.beforeValidate' => array('callable' => 'beforeValidate', 'passParams' => true),\n\t\t\t'Model.afterValidate' => array('callable' => 'afterValidate'),\n\t\t\t'Model.beforeSave' => array('callable' => 'beforeSave', 'passParams' => true),\n\t\t\t'Model.afterSave' => array('callable' => 'afterSave', 'passParams' => true),\n\t\t\t'Model.beforeDelete' => array('callable' => 'beforeDelete', 'passParams' => true),\n\t\t\t'Model.afterDelete' => array('callable' => 'afterDelete'),\n\t\t);\n\t}\n\n/**\n * Returns the CakeEventManager manager instance that is handling any callbacks.\n * You can use this instance to register any new listeners or callbacks to the\n * model events, or create your own events and trigger them at will.\n *\n * @return CakeEventManager\n */\n\tpublic function getEventManager() {\n\t\tif (empty($this->_eventManager)) {\n\t\t\t$this->_eventManager = new CakeEventManager();\n\t\t\t$this->_eventManager->attach($this->Behaviors);\n\t\t\t$this->_eventManager->attach($this);\n\t\t}\n\t\treturn $this->_eventManager;\n\t}\n\n/**\n * Handles custom method calls, like findBy<field> for DB models,\n * and custom RPC calls for remote data sources.\n *\n * @param string $method Name of method to call.\n * @param array $params Parameters for the method.\n * @return mixed Whatever is returned by called method\n */\n\tpublic function __call($method, $params) {\n\t\t$result = $this->Behaviors->dispatchMethod($this, $method, $params);\n\t\tif ($result !== array('unhandled')) {\n\t\t\treturn $result;\n\t\t}\n\t\t$return = $this->getDataSource()->query($method, $params, $this);\n\t\treturn $return;\n\t}\n\n/**\n * Handles the lazy loading of model associations by looking in the association arrays for the requested variable\n *\n * @param string $name variable tested for existence in class\n * @return boolean true if the variable exists (if is a not loaded model association it will be created), false otherwise\n */\n\tpublic function __isset($name) {\n\t\t$className = false;\n\n\t\tforeach ($this->_associations as $type) {\n\t\t\tif (isset($name, $this->{$type}[$name])) {\n\t\t\t\t$className = empty($this->{$type}[$name]['className']) ? $name : $this->{$type}[$name]['className'];\n\t\t\t\tbreak;\n\t\t\t} elseif (isset($name, $this->__backAssociation[$type][$name])) {\n\t\t\t\t$className = empty($this->__backAssociation[$type][$name]['className']) ?\n\t\t\t\t\t$name : $this->__backAssociation[$type][$name]['className'];\n\t\t\t\tbreak;\n\t\t\t} elseif ($type === 'hasAndBelongsToMany') {\n\t\t\t\tforeach ($this->{$type} as $k => $relation) {\n\t\t\t\t\tif (empty($relation['with'])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (is_array($relation['with'])) {\n\t\t\t\t\t\tif (key($relation['with']) === $name) {\n\t\t\t\t\t\t\t$className = $name;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlist($plugin, $class) = pluginSplit($relation['with']);\n\t\t\t\t\t\tif ($class === $name) {\n\t\t\t\t\t\t\t$className = $relation['with'];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($className) {\n\t\t\t\t\t\t$assocKey = $k;\n\t\t\t\t\t\t$dynamic = !empty($relation['dynamicWith']);\n\t\t\t\t\t\tbreak(2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!$className) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlist($plugin, $className) = pluginSplit($className);\n\n\t\tif (!ClassRegistry::isKeySet($className) && !empty($dynamic)) {\n\t\t\t$this->{$className} = new AppModel(array(\n\t\t\t\t'name' => $className,\n\t\t\t\t'table' => $this->hasAndBelongsToMany[$assocKey]['joinTable'],\n\t\t\t\t'ds' => $this->useDbConfig\n\t\t\t));\n\t\t} else {\n\t\t\t$this->_constructLinkedModel($name, $className, $plugin);\n\t\t}\n\n\t\tif (!empty($assocKey)) {\n\t\t\t$this->hasAndBelongsToMany[$assocKey]['joinTable'] = $this->{$name}->table;\n\t\t\tif (count($this->{$name}->schema()) <= 2 && $this->{$name}->primaryKey !== false) {\n\t\t\t\t$this->{$name}->primaryKey = $this->hasAndBelongsToMany[$assocKey]['foreignKey'];\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n/**\n * Returns the value of the requested variable if it can be set by __isset()\n *\n * @param string $name variable requested for it's value or reference\n * @return mixed value of requested variable if it is set\n */\n\tpublic function __get($name) {\n\t\tif ($name === 'displayField') {\n\t\t\treturn $this->displayField = $this->hasField(array('title', 'name', $this->primaryKey));\n\t\t}\n\t\tif ($name === 'tablePrefix') {\n\t\t\t$this->setDataSource();\n\t\t\tif (property_exists($this, 'tablePrefix') && !empty($this->tablePrefix)) {\n\t\t\t\treturn $this->tablePrefix;\n\t\t\t}\n\t\t\treturn $this->tablePrefix = null;\n\t\t}\n\t\tif (isset($this->{$name})) {\n\t\t\treturn $this->{$name};\n\t\t}\n\t}\n\n/**\n * Bind model associations on the fly.\n *\n * If `$reset` is false, association will not be reset\n * to the originals defined in the model\n *\n * Example: Add a new hasOne binding to the Profile model not\n * defined in the model source code:\n *\n * `$this->User->bindModel( array('hasOne' => array('Profile')) );`\n *\n * Bindings that are not made permanent will be reset by the next Model::find() call on this\n * model.\n *\n * @param array $params Set of bindings (indexed by binding type)\n * @param boolean $reset Set to false to make the binding permanent\n * @return boolean Success\n * @link http://book.cakephp.org/2.0/en/models/associations-linking-models-together.html#creating-and-destroying-associations-on-the-fly\n */\n\tpublic function bindModel($params, $reset = true) {\n\t\tforeach ($params as $assoc => $model) {\n\t\t\tif ($reset === true && !isset($this->__backAssociation[$assoc])) {\n\t\t\t\t$this->__backAssociation[$assoc] = $this->{$assoc};\n\t\t\t}\n\t\t\tforeach ($model as $key => $value) {\n\t\t\t\t$assocName = $key;\n\n\t\t\t\tif (is_numeric($key)) {\n\t\t\t\t\t$assocName = $value;\n\t\t\t\t\t$value = array();\n\t\t\t\t}\n\t\t\t\t$this->{$assoc}[$assocName] = $value;\n\t\t\t\tif (property_exists($this, $assocName)) {\n\t\t\t\t\tunset($this->{$assocName});\n\t\t\t\t}\n\t\t\t\tif ($reset === false && isset($this->__backAssociation[$assoc])) {\n\t\t\t\t\t$this->__backAssociation[$assoc][$assocName] = $value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$this->_createLinks();\n\t\treturn true;\n\t}\n\n/**\n * Turn off associations on the fly.\n *\n * If $reset is false, association will not be reset\n * to the originals defined in the model\n *\n * Example: Turn off the associated Model Support request,\n * to temporarily lighten the User model:\n *\n * `$this->User->unbindModel( array('hasMany' => array('Supportrequest')) );`\n *\n * unbound models that are not made permanent will reset with the next call to Model::find()\n *\n * @param array $params Set of bindings to unbind (indexed by binding type)\n * @param boolean $reset Set to false to make the unbinding permanent\n * @return boolean Success\n * @link http://book.cakephp.org/2.0/en/models/associations-linking-models-together.html#creating-and-destroying-associations-on-the-fly\n */\n\tpublic function unbindModel($params, $reset = true) {\n\t\tforeach ($params as $assoc => $models) {\n\t\t\tif ($reset === true && !isset($this->__backAssociation[$assoc])) {\n\t\t\t\t$this->__backAssociation[$assoc] = $this->{$assoc};\n\t\t\t}\n\t\t\tforeach ($models as $model) {\n\t\t\t\tif ($reset === false && isset($this->__backAssociation[$assoc][$model])) {\n\t\t\t\t\tunset($this->__backAssociation[$assoc][$model]);\n\t\t\t\t}\n\t\t\t\tunset($this->{$assoc}[$model]);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n/**\n * Create a set of associations.\n *\n * @return void\n */\n\tprotected function _createLinks() {\n\t\tforeach ($this->_associations as $type) {\n\t\t\tif (!is_array($this->{$type})) {\n\t\t\t\t$this->{$type} = explode(',', $this->{$type});\n\n\t\t\t\tforeach ($this->{$type} as $i => $className) {\n\t\t\t\t\t$className = trim($className);\n\t\t\t\t\tunset ($this->{$type}[$i]);\n\t\t\t\t\t$this->{$type}[$className] = array();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!empty($this->{$type})) {\n\t\t\t\tforeach ($this->{$type} as $assoc => $value) {\n\t\t\t\t\t$plugin = null;\n\n\t\t\t\t\tif (is_numeric($assoc)) {\n\t\t\t\t\t\tunset($this->{$type}[$assoc]);\n\t\t\t\t\t\t$assoc = $value;\n\t\t\t\t\t\t$value = array();\n\n\t\t\t\t\t\tif (strpos($assoc, '.') !== false) {\n\t\t\t\t\t\t\tlist($plugin, $assoc) = pluginSplit($assoc, true);\n\t\t\t\t\t\t\t$this->{$type}[$assoc] = array('className' => $plugin . $assoc);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$this->{$type}[$assoc] = $value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$this->_generateAssociation($type, $assoc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n/**\n * Protected helper method to create associated models of a given class.\n *\n * @param string $assoc Association name\n * @param string $className Class name\n * @param string $plugin name of the plugin where $className is located\n * \texamples: public $hasMany = array('Assoc' => array('className' => 'ModelName'));\n * \t\t\t\t\tusage: $this->Assoc->modelMethods();\n *\n * \t\t\t\tpublic $hasMany = array('ModelName');\n * \t\t\t\t\tusage: $this->ModelName->modelMethods();\n * @return void\n */\n\tprotected function _constructLinkedModel($assoc, $className = null, $plugin = null) {\n\t\tif (empty($className)) {\n\t\t\t$className = $assoc;\n\t\t}\n\n\t\tif (!isset($this->{$assoc}) || $this->{$assoc}->name !== $className) {\n\t\t\tif ($plugin) {\n\t\t\t\t$plugin .= '.';\n\t\t\t}\n\t\t\t$model = array('class' => $plugin . $className, 'alias' => $assoc);\n\t\t\t$this->{$assoc} = ClassRegistry::init($model);\n\t\t\tif ($plugin) {\n\t\t\t\tClassRegistry::addObject($plugin . $className, $this->{$assoc});\n\t\t\t}\n\t\t\tif ($assoc) {\n\t\t\t\t$this->tableToModel[$this->{$assoc}->table] = $assoc;\n\t\t\t}\n\t\t}\n\t}\n\n/**\n * Build an array-based association from string.\n *\n * @param string $type 'belongsTo', 'hasOne', 'hasMany', 'hasAndBelongsToMany'\n * @param string $assocKey\n * @return void\n */\n\tprotected function _generateAssociation($type, $assocKey) {\n\t\t$class = $assocKey;\n\t\t$dynamicWith = false;\n\n\t\tforeach ($this->_associationKeys[$type] as $key) {\n\n\t\t\tif (!isset($this->{$type}[$assocKey][$key]) || $this->{$type}[$assocKey][$key] === null) {\n\t\t\t\t$data = '';\n\n\t\t\t\tswitch ($key) {\n\t\t\t\t\tcase 'fields':\n\t\t\t\t\t\t$data = '';\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'foreignKey':\n\t\t\t\t\t\t$data = (($type === 'belongsTo') ? Inflector::underscore($assocKey) : Inflector::singularize($this->table)) . '_id';\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'associationForeignKey':\n\t\t\t\t\t\t$data = Inflector::singularize($this->{$class}->table) . '_id';\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'with':\n\t\t\t\t\t\t$data = Inflector::camelize(Inflector::singularize($this->{$type}[$assocKey]['joinTable']));\n\t\t\t\t\t\t$dynamicWith = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'joinTable':\n\t\t\t\t\t\t$tables = array($this->table, $this->{$class}->table);\n\t\t\t\t\t\tsort($tables);\n\t\t\t\t\t\t$data = $tables[0] . '_' . $tables[1];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'className':\n\t\t\t\t\t\t$data = $class;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'unique':\n\t\t\t\t\t\t$data = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t$this->{$type}[$assocKey][$key] = $data;\n\t\t\t}\n\n\t\t\tif ($dynamicWith) {\n\t\t\t\t$this->{$type}[$assocKey]['dynamicWith'] = true;\n\t\t\t}\n\n\t\t}\n\t}\n\n/**\n * Sets a custom table for your model class. Used by your controller to select a database table.\n *\n * @param string $tableName Name of the custom table\n * @throws MissingTableException when database table $tableName is not found on data source\n * @return void\n */\n\tpublic function setSource($tableName) {\n\t\t$this->setDataSource($this->useDbConfig);\n\t\t$db = ConnectionManager::getDataSource($this->useDbConfig);\n\t\t$db->cacheSources = ($this->cacheSources && $db->cacheSources);\n\n\t\tif (method_exists($db, 'listSources')) {\n\t\t\t$sources = $db->listSources();\n\t\t\tif (is_array($sources) && !in_array(strtolower($this->tablePrefix . $tableName), array_map('strtolower', $sources))) {\n\t\t\t\tthrow new MissingTableException(array(\n\t\t\t\t\t'table' => $this->tablePrefix . $tableName,\n\t\t\t\t\t'class' => $this->alias,\n\t\t\t\t\t'ds' => $this->useDbConfig,\n\t\t\t\t));\n\t\t\t}\n\t\t\t$this->_schema = null;\n\t\t}\n\t\t$this->table = $this->useTable = $tableName;\n\t\t$this->tableToModel[$this->table] = $this->alias;\n\t}\n\n/**\n * This function does two things:\n *\n * 1. it scans the array $one for the primary key,\n * and if that's found, it sets the current id to the value of $one[id].\n * For all other keys than 'id' the keys and values of $one are copied to the 'data' property of this object.\n * 2. Returns an array with all of $one's keys and values.\n * (Alternative indata: two strings, which are mangled to\n * a one-item, two-dimensional array using $one for a key and $two as its value.)\n *\n * @param string|array|SimpleXmlElement|DomNode $one Array or string of data\n * @param string $two Value string for the alternative indata method\n * @return array Data with all of $one's keys and values\n * @link http://book.cakephp.org/2.0/en/models/saving-your-data.html\n */\n\tpublic function set($one, $two = null) {\n\t\tif (!$one) {\n\t\t\treturn;\n\t\t}\n\t\tif (is_object($one)) {\n\t\t\tif ($one instanceof SimpleXMLElement || $one instanceof DOMNode) {\n\t\t\t\t$one = $this->_normalizeXmlData(Xml::toArray($one));\n\t\t\t} else {\n\t\t\t\t$one = Set::reverse($one);\n\t\t\t}\n\t\t}\n\n\t\tif (is_array($one)) {\n\t\t\t$data = $one;\n\t\t\tif (empty($one[$this->alias])) {\n\t\t\t\t$data = $this->_setAliasData($one);\n\t\t\t}\n\t\t} else {\n\t\t\t$data = array($this->alias => array($one => $two));\n\t\t}\n\n\t\tforeach ($data as $modelName => $fieldSet) {\n\t\t\tif (is_array($fieldSet)) {\n\n\t\t\t\tforeach ($fieldSet as $fieldName => $fieldValue) {\n\t\t\t\t\tif (isset($this->validationErrors[$fieldName])) {\n\t\t\t\t\t\tunset($this->validationErrors[$fieldName]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif ($modelName === $this->alias) {\n\t\t\t\t\t\tif ($fieldName === $this->primaryKey) {\n\t\t\t\t\t\t\t$this->id = $fieldValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (is_array($fieldValue) || is_object($fieldValue)) {\n\t\t\t\t\t\t$fieldValue = $this->deconstruct($fieldName, $fieldValue);\n\t\t\t\t\t}\n\t\t\t\t\t$this->data[$modelName][$fieldName] = $fieldValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $data;\n\t}\n\n/**\n * Move values to alias\n *\n * @param array $data\n * @return array\n */\n\tprotected function _setAliasData($data) {\n\t\t$models = array_keys($this->getAssociated());\n\t\t$schema = array_keys((array)$this->schema());\n\t\tforeach ($data as $field => $value) {\n\t\t\tif (in_array($field, $schema) || !in_array($field, $models)) {\n\t\t\t\t$data[$this->alias][$field] = $value;\n\t\t\t\tunset($data[$field]);\n\t\t\t}\n\t\t}\n\t\treturn $data;\n\t}\n\n/**\n * Normalize `Xml::toArray()` to use in `Model::save()`\n *\n * @param array $xml XML as array\n * @return array\n */\n\tprotected function _normalizeXmlData(array $xml) {\n\t\t$return = array();\n\t\tforeach ($xml as $key => $value) {\n\t\t\tif (is_array($value)) {\n\t\t\t\t$return[Inflector::camelize($key)] = $this->_normalizeXmlData($value);\n\t\t\t} elseif ($key[0] === '@') {\n\t\t\t\t$return[substr($key, 1)] = $value;\n\t\t\t} else {\n\t\t\t\t$return[$key] = $value;\n\t\t\t}\n\t\t}\n\t\treturn $return;\n\t}\n\n/**\n * Deconstructs a complex data type (array or object) into a single field value.\n *\n * @param string $field The name of the field to be deconstructed\n * @param array|object $data An array or object to be deconstructed into a field\n * @return mixed The resulting data that should be assigned to a field\n */\n\tpublic function deconstruct($field, $data) {\n\t\tif (!is_array($data)) {\n\t\t\treturn $data;\n\t\t}\n\n\t\t$type = $this->getColumnType($field);\n\n\t\tif (!in_array($type, array('datetime', 'timestamp', 'date', 'time'))) {\n\t\t\treturn $data;\n\t\t}\n\n\t\t$useNewDate = (isset($data['year']) || isset($data['month']) ||\n\t\t\tisset($data['day']) || isset($data['hour']) || isset($data['minute']));\n\n\t\t$dateFields = array('Y' => 'year', 'm' => 'month', 'd' => 'day', 'H' => 'hour', 'i' => 'min', 's' => 'sec');\n\t\t$timeFields = array('H' => 'hour', 'i' => 'min', 's' => 'sec');\n\t\t$date = array();\n\n\t\tif (isset($data['meridian']) && empty($data['meridian'])) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (\n\t\t\tisset($data['hour']) &&\n\t\t\tisset($data['meridian']) &&\n\t\t\t!empty($data['hour']) &&\n\t\t\t$data['hour'] != 12 &&\n\t\t\t$data['meridian'] === 'pm'\n\t\t) {\n\t\t\t$data['hour'] = $data['hour'] + 12;\n\t\t}\n\t\tif (isset($data['hour']) && isset($data['meridian']) && $data['hour'] == 12 && $data['meridian'] === 'am') {\n\t\t\t$data['hour'] = '00';\n\t\t}\n\t\tif ($type === 'time') {\n\t\t\tforeach ($timeFields as $key => $val) {\n\t\t\t\tif (!isset($data[$val]) || $data[$val] === '0' || $data[$val] === '00') {\n\t\t\t\t\t$data[$val] = '00';\n\t\t\t\t} elseif ($data[$val] !== '') {\n\t\t\t\t\t$data[$val] = sprintf('%02d', $data[$val]);\n\t\t\t\t}\n\t\t\t\tif (!empty($data[$val])) {\n\t\t\t\t\t$date[$key] = $data[$val];\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ($type === 'datetime' || $type === 'timestamp' || $type === 'date') {\n\t\t\tforeach ($dateFields as $key => $val) {\n\t\t\t\tif ($val === 'hour' || $val === 'min' || $val === 'sec') {\n\t\t\t\t\tif (!isset($data[$val]) || $data[$val] === '0' || $data[$val] === '00') {\n\t\t\t\t\t\t$data[$val] = '00';\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$data[$val] = sprintf('%02d', $data[$val]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!isset($data[$val]) || isset($data[$val]) && (empty($data[$val]) || $data[$val][0] === '-')) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (isset($data[$val]) && !empty($data[$val])) {\n\t\t\t\t\t$date[$key] = $data[$val];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ($useNewDate && !empty($date)) {\n\t\t\t$format = $this->getDataSource()->columns[$type]['format'];\n\t\t\tforeach (array('m', 'd', 'H', 'i', 's') as $index) {\n\t\t\t\tif (isset($date[$index])) {\n\t\t\t\t\t$date[$index] = sprintf('%02d', $date[$index]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn str_replace(array_keys($date), array_values($date), $format);\n\t\t}\n\t\treturn $data;\n\t}\n\n/**\n * Returns an array of table metadata (column names and types) from the database.\n * $field => keys(type, null, default, key, length, extra)\n *\n * @param boolean|string $field Set to true to reload schema, or a string to return a specific field\n * @return array Array of table metadata\n */\n\tpublic function schema($field = false) {\n\t\tif ($this->useTable !== false && (!is_array($this->_schema) || $field === true)) {\n\t\t\t$db = $this->getDataSource();\n\t\t\t$db->cacheSources = ($this->cacheSources && $db->cacheSources);\n\t\t\tif (method_exists($db, 'describe')) {\n\t\t\t\t$this->_schema = $db->describe($this);\n\t\t\t}\n\t\t}\n\t\tif (!is_string($field)) {\n\t\t\treturn $this->_schema;\n\t\t}\n\t\tif (isset($this->_schema[$field])) {\n\t\t\treturn $this->_schema[$field];\n\t\t}\n\t\treturn null;\n\t}\n\n/**\n * Returns an associative array of field names and column types.\n *\n * @return array Field types indexed by field name\n */\n\tpublic function getColumnTypes() {\n\t\t$columns = $this->schema();\n\t\tif (empty($columns)) {\n\t\t\ttrigger_error(__d('cake_dev', '(Model::getColumnTypes) Unable to build model field data. If you are using a model without a database table, try implementing schema()'), E_USER_WARNING);\n\t\t}\n\t\t$cols = array();\n\t\tforeach ($columns as $field => $values) {\n\t\t\t$cols[$field] = $values['type'];\n\t\t}\n\t\treturn $cols;\n\t}\n\n/**\n * Returns the column type of a column in the model.\n *\n * @param string $column The name of the model column\n * @return string Column type\n */\n\tpublic function getColumnType($column) {\n\t\t$db = $this->getDataSource();\n\t\t$cols = $this->schema();\n\t\t$model = null;\n\n\t\t$startQuote = isset($db->startQuote) ? $db->startQuote : null;\n\t\t$endQuote = isset($db->endQuote) ? $db->endQuote : null;\n\t\t$column = str_replace(array($startQuote, $endQuote), '', $column);\n\n\t\tif (strpos($column, '.')) {\n\t\t\tlist($model, $column) = explode('.', $column);\n\t\t}\n\t\tif ($model != $this->alias && isset($this->{$model})) {\n\t\t\treturn $this->{$model}->getColumnType($column);\n\t\t}\n\t\tif (isset($cols[$column]) && isset($cols[$column]['type'])) {\n\t\t\treturn $cols[$column]['type'];\n\t\t}\n\t\treturn null;\n\t}\n\n/**\n * Returns true if the supplied field exists in the model's database table.\n *\n * @param string|array $name Name of field to look for, or an array of names\n * @param boolean $checkVirtual checks if the field is declared as virtual\n * @return mixed If $name is a string, returns a boolean indicating whether the field exists.\n *               If $name is an array of field names, returns the first field that exists,\n *               or false if none exist.\n */\n\tpublic function hasField($name, $checkVirtual = false) {\n\t\tif (is_array($name)) {\n\t\t\tforeach ($name as $n) {\n\t\t\t\tif ($this->hasField($n, $checkVirtual)) {\n\t\t\t\t\treturn $n;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tif ($checkVirtual && !empty($this->virtualFields) && $this->isVirtualField($name)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (empty($this->_schema)) {\n\t\t\t$this->schema();\n\t\t}\n\n\t\tif ($this->_schema) {\n\t\t\treturn isset($this->_schema[$name]);\n\t\t}\n\t\treturn false;\n\t}\n\n/**\n * Check that a method is callable on a model. This will check both the model's own methods, its\n * inherited methods and methods that could be callable through behaviors.\n *\n * @param string $method The method to be called.\n * @return boolean True on method being callable.\n */\n\tpublic function hasMethod($method) {\n\t\tif (method_exists($this, $method)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn $this->Behaviors->hasMethod($method);\n\t}\n\n/**\n * Returns true if the supplied field is a model Virtual Field\n *\n * @param string $field Name of field to look for\n * @return boolean indicating whether the field exists as a model virtual field.\n */\n\tpublic function isVirtualField($field) {\n\t\tif (empty($this->virtualFields) || !is_string($field)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (isset($this->virtualFields[$field])) {\n\t\t\treturn true;\n\t\t}\n\t\tif (strpos($field, '.') !== false) {\n\t\t\tlist($model, $field) = explode('.', $field);\n\t\t\tif ($model == $this->alias && isset($this->virtualFields[$field])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n/**\n * Returns the expression for a model virtual field\n *\n * @param string $field Name of field to look for\n * @return mixed If $field is string expression bound to virtual field $field\n *    If $field is null, returns an array of all model virtual fields\n *    or false if none $field exist.\n */\n\tpublic function getVirtualField($field = null) {\n\t\tif (!$field) {\n\t\t\treturn empty($this->virtualFields) ? false : $this->virtualFields;\n\t\t}\n\t\tif ($this->isVirtualField($field)) {\n\t\t\tif (strpos($field, '.') !== false) {\n\t\t\t\tlist(, $field) = pluginSplit($field);\n\t\t\t}\n\t\t\treturn $this->virtualFields[$field];\n\t\t}\n\t\treturn false;\n\t}\n\n/**\n * Initializes the model for writing a new record, loading the default values\n * for those fields that are not defined in $data, and clearing previous validation errors.\n * Especially helpful for saving data in loops.\n *\n * @param boolean|array $data Optional data array to assign to the model after it is created. If null or false,\n *   schema data defaults are not merged.\n * @param boolean $filterKey If true, overwrites any primary key input with an empty value\n * @return array The current Model::data; after merging $data and/or defaults from database\n * @link http://book.cakephp.org/2.0/en/models/saving-your-data.html#model-create-array-data-array\n */\n\tpublic function create($data = array(), $filterKey = false) {\n\t\t$defaults = array();\n\t\t$this->id = false;\n\t\t$this->data = array();\n\t\t$this->validationErrors = array();\n\n\t\tif ($data !== null && $data !== false) {\n\t\t\t$schema = (array)$this->schema();\n\t\t\tforeach ($schema as $field => $properties) {\n\t\t\t\tif ($this->primaryKey !== $field && isset($properties['default']) && $properties['default'] !== '') {\n\t\t\t\t\t$defaults[$field] = $properties['default'];\n\t\t\t\t}\n\t\t\t}\n\t\t\t$this->set($defaults);\n\t\t\t$this->set($data);\n\t\t}\n\t\tif ($filterKey) {\n\t\t\t$this->set($this->primaryKey, false);\n\t\t}\n\t\treturn $this->data;\n\t}\n\n/**\n * Returns a list of fields from the database, and sets the current model\n * data (Model::$data) with the record found.\n *\n * @param string|array $fields String of single field name, or an array of field names.\n * @param integer|string $id The ID of the record to read\n * @return array Array of database fields, or false if not found\n * @link http://book.cakephp.org/2.0/en/models/retrieving-your-data.html#model-read\n */\n\tpublic function read($fields = null, $id = null) {\n\t\t$this->validationErrors = array();\n\n\t\tif ($id) {\n\t\t\t$this->id = $id;\n\t\t}\n\n\t\t$id = $this->id;\n\n\t\tif (is_array($this->id)) {\n\t\t\t$id = $this->id[0];\n\t\t}\n\n\t\tif ($id !== null && $id !== false) {\n\t\t\t$this->data = $this->find('first', array(\n\t\t\t\t'conditions' => array($this->alias . '.' . $this->primaryKey => $id),\n\t\t\t\t'fields' => $fields\n\t\t\t));\n\t\t\treturn $this->data;\n\t\t}\n\t\treturn false;\n\t}\n\n/**\n * Returns the contents of a single field given the supplied conditions, in the\n * supplied order.\n *\n * @param string $name Name of field to get\n * @param array $conditions SQL conditions (defaults to NULL)\n * @param string $order SQL ORDER BY fragment\n * @return string field contents, or false if not found\n * @link http://book.cakephp.org/2.0/en/models/retrieving-your-data.html#model-field\n */\n\tpublic function field($name, $conditions = null, $order = null) {\n\t\tif ($conditions === null && $this->id !== false) {\n\t\t\t$conditions = array($this->alias . '.' . $this->primaryKey => $this->id);\n\t\t}\n\t\t$recursive = $this->recursive;\n\t\tif ($this->recursive >= 1) {\n\t\t\t$recursive = -1;\n\t\t}\n\t\t$fields = $name;\n\t\t$data = $this->find('first', compact('conditions', 'fields', 'order', 'recursive'));\n\t\tif (!$data) {\n\t\t\treturn false;\n\t\t}\n\t\tif (strpos($name, '.') === false) {\n\t\t\tif (isset($data[$this->alias][$name])) {\n\t\t\t\treturn $data[$this->alias][$name];\n\t\t\t}\n\t\t} else {\n\t\t\t$name = explode('.', $name);\n\t\t\tif (isset($data[$name[0]][$name[1]])) {\n\t\t\t\treturn $data[$name[0]][$name[1]];\n\t\t\t}\n\t\t}\n\t\tif (isset($data[0]) && count($data[0]) > 0) {\n\t\t\treturn array_shift($data[0]);\n\t\t}\n\t}\n\n/**\n * Saves the value of a single field to the database, based on the current\n * model ID.\n *\n * @param string $name Name of the table field\n * @param mixed $value Value of the field\n * @param boolean|array $validate Either a boolean, or an array.\n *   If a boolean, indicates whether or not to validate before saving.\n *   If an array, allows control of 'validate' and 'callbacks' options.\n * @return boolean See Model::save()\n * @see Model::save()\n * @link http://book.cakephp.org/2.0/en/models/saving-your-data.html#model-savefield-string-fieldname-string-fieldvalue-validate-false\n */\n\tpublic function saveField($name, $value, $validate = false) {\n\t\t$id = $this->id;\n\t\t$this->create(false);\n\n\t\t$options = array('validate' => $validate, 'fieldList' => array($name));\n\t\tif (is_array($validate)) {\n\t\t\t$options = array_merge(array('validate' => false, 'fieldList' => array($name)), $validate);\n\t\t}\n\t\treturn $this->save(array($this->alias => array($this->primaryKey => $id, $name => $value)), $options);\n\t}\n\n/**\n * Saves model data (based on white-list, if supplied) to the database. By\n * default, validation occurs before save.\n *\n * @param array $data Data to save.\n * @param boolean|array $validate Either a boolean, or an array.\n *   If a boolean, indicates whether or not to validate before saving.\n *   If an array, can have following keys:\n *\n *   - validate: Set to true/false to enable or disable validation.\n *   - fieldList: An array of fields you want to allow for saving.\n *   - callbacks: Set to false to disable callbacks. Using 'before' or 'after'\n *      will enable only those callbacks.\n *\n * @param array $fieldList List of fields to allow to be saved\n * @return mixed On success Model::$data if its not empty or true, false on failure\n * @link http://book.cakephp.org/2.0/en/models/saving-your-data.html\n */\n\tpublic function save($data = null, $validate = true, $fieldList = array()) {\n\t\t$defaults = array('validate' => true, 'fieldList' => array(), 'callbacks' => true);\n\t\t$_whitelist = $this->whitelist;\n\t\t$fields = array();\n\n\t\tif (!is_array($validate)) {\n\t\t\t$options = array_merge($defaults, compact('validate', 'fieldList'));\n\t\t} else {\n\t\t\t$options = array_merge($defaults, $validate);\n\t\t}\n\n\t\tif (!empty($options['fieldList'])) {\n\t\t\tif (!empty($options['fieldList'][$this->alias]) && is_array($options['fieldList'][$this->alias])) {\n\t\t\t\t$this->whitelist = $options['fieldList'][$this->alias];\n\t\t\t} elseif (Hash::dimensions($options['fieldList']) < 2) {\n\t\t\t\t$this->whitelist = $options['fieldList'];\n\t\t\t}\n\t\t} elseif ($options['fieldList'] === null) {\n\t\t\t$this->whitelist = array();\n\t\t}\n\t\t$this->set($data);\n\n\t\tif (empty($this->data) && !$this->hasField(array('created', 'updated', 'modified'))) {\n\t\t\t$this->whitelist = $_whitelist;\n\t\t\treturn false;\n\t\t}\n\n\t\tforeach (array('created', 'updated', 'modified') as $field) {\n\t\t\t$keyPresentAndEmpty = (\n\t\t\t\tisset($this->data[$this->alias]) &&\n\t\t\t\tarray_key_exists($field, $this->data[$this->alias]) &&\n\t\t\t\t$this->data[$this->alias][$field] === null\n\t\t\t);\n\t\t\tif ($keyPresentAndEmpty) {\n\t\t\t\tunset($this->data[$this->alias][$field]);\n\t\t\t}\n\t\t}\n\n\t\t$exists = $this->exists();\n\t\t$dateFields = array('modified', 'updated');\n\n\t\tif (!$exists) {\n\t\t\t$dateFields[] = 'created';\n\t\t}\n\t\tif (isset($this->data[$this->alias])) {\n\t\t\t$fields = array_keys($this->data[$this->alias]);\n\t\t}\n\t\tif ($options['validate'] && !$this->validates($options)) {\n\t\t\t$this->whitelist = $_whitelist;\n\t\t\treturn false;\n\t\t}\n\n\t\t$db = $this->getDataSource();\n\t\t$now = time();\n\n\t\tforeach ($dateFields as $updateCol) {\n\t\t\tif ($this->hasField($updateCol) && !in_array($updateCol, $fields)) {\n\t\t\t\t$default = array('formatter' => 'date');\n\t\t\t\t$colType = array_merge($default, $db->columns[$this->getColumnType($updateCol)]);\n\t\t\t\tif (!array_key_exists('format', $colType)) {\n\t\t\t\t\t$time = $now;\n\t\t\t\t} else {\n\t\t\t\t\t$time = call_user_func($colType['formatter'], $colType['format']);\n\t\t\t\t}\n\t\t\t\tif (!empty($this->whitelist)) {\n\t\t\t\t\t$this->whitelist[] = $updateCol;\n\t\t\t\t}\n\t\t\t\t$this->set($updateCol, $time);\n\t\t\t}\n\t\t}\n\n\t\tif ($options['callbacks'] === true || $options['callbacks'] === 'before') {\n\t\t\t$event = new CakeEvent('Model.beforeSave', $this, array($options));\n\t\t\tlist($event->break, $event->breakOn) = array(true, array(false, null));\n\t\t\t$this->getEventManager()->dispatch($event);\n\t\t\tif (!$event->result) {\n\t\t\t\t$this->whitelist = $_whitelist;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t$db = $this->getDataSource();\n\n\t\tif (empty($this->data[$this->alias][$this->primaryKey])) {\n\t\t\tunset($this->data[$this->alias][$this->primaryKey]);\n\t\t}\n\t\t$fields = $values = array();\n\n\t\tforeach ($this->data as $n => $v) {\n\t\t\tif (isset($this->hasAndBelongsToMany[$n])) {\n\t\t\t\tif (isset($v[$n])) {\n\t\t\t\t\t$v = $v[$n];\n\t\t\t\t}\n\t\t\t\t$joined[$n] = $v;\n\t\t\t} else {\n\t\t\t\tif ($n === $this->alias) {\n\t\t\t\t\tforeach (array('created', 'updated', 'modified') as $field) {\n\t\t\t\t\t\tif (array_key_exists($field, $v) && empty($v[$field])) {\n\t\t\t\t\t\t\tunset($v[$field]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tforeach ($v as $x => $y) {\n\t\t\t\t\t\tif ($this->hasField($x) && (empty($this->whitelist) || in_array($x, $this->whitelist))) {\n\t\t\t\t\t\t\tlist($fields[], $values[]) = array($x, $y);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$count = count($fields);\n\n\t\tif (!$exists && $count > 0) {\n\t\t\t$this->id = false;\n\t\t}\n\t\t$success = true;\n\t\t$created = false;\n\n\t\tif ($count > 0) {\n\t\t\t$cache = $this->_prepareUpdateFields(array_combine($fields, $values));\n\n\t\t\tif (!empty($this->id)) {\n\t\t\t\t$success = (bool)$db->update($this, $fields, $values);\n\t\t\t} else {\n\t\t\t\tif (empty($this->data[$this->alias][$this->primaryKey]) && $this->_isUUIDField($this->primaryKey)) {\n\t\t\t\t\tif (array_key_exists($this->primaryKey, $this->data[$this->alias])) {\n\t\t\t\t\t\t$j = array_search($this->primaryKey, $fields);\n\t\t\t\t\t\t$values[$j] = String::uuid();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlist($fields[], $values[]) = array($this->primaryKey, String::uuid());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!$db->create($this, $fields, $values)) {\n\t\t\t\t\t$success = false;\n\t\t\t\t} else {\n\t\t\t\t\t$created = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ($success && !empty($this->belongsTo)) {\n\t\t\t\t$this->updateCounterCache($cache, $created);\n\t\t\t}\n\t\t}\n\n\t\tif (!empty($joined) && $success === true) {\n\t\t\t$this->_saveMulti($joined, $this->id, $db);\n\t\t}\n\n\t\tif ($success && $count === 0) {\n\t\t\t$success = false;\n\t\t}\n\n\t\tif ($success && $count > 0) {\n\t\t\tif (!empty($this->data)) {\n\t\t\t\tif ($created) {\n\t\t\t\t\t$this->data[$this->alias][$this->primaryKey] = $this->id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($options['callbacks'] === true || $options['callbacks'] === 'after') {\n\t\t\t\t$event = new CakeEvent('Model.afterSave', $this, array($created, $options));\n\t\t\t\t$this->getEventManager()->dispatch($event);\n\t\t\t}\n\t\t\tif (!empty($this->data)) {\n\t\t\t\t$success = $this->data;\n\t\t\t}\n\t\t\t$this->data = false;\n\t\t\t$this->_clearCache();\n\t\t\t$this->validationErrors = array();\n\t\t}\n\t\t$this->whitelist = $_whitelist;\n\t\treturn $success;\n\t}\n\n/**\n * Check if the passed in field is a UUID field\n *\n * @param string $field the field to check\n * @return boolean\n */\n\tprotected function _isUUIDField($field) {\n\t\t$field = $this->schema($field);\n\t\treturn $field['length'] == 36 && in_array($field['type'], array('string', 'binary'));\n\t}\n\n/**\n * Saves model hasAndBelongsToMany data to the database.\n *\n * @param array $joined Data to save\n * @param integer|string $id ID of record in this model\n * @param DataSource $db\n * @return void\n */\n\tprotected function _saveMulti($joined, $id, $db) {\n\t\tforeach ($joined as $assoc => $data) {\n\n\t\t\tif (isset($this->hasAndBelongsToMany[$assoc])) {\n\t\t\t\tlist($join) = $this->joinModel($this->hasAndBelongsToMany[$assoc]['with']);\n\n\t\t\t\tif ($with = $this->hasAndBelongsToMany[$assoc]['with']) {\n\t\t\t\t\t$withModel = is_array($with) ? key($with) : $with;\n\t\t\t\t\tlist(, $withModel) = pluginSplit($withModel);\n\t\t\t\t\t$dbMulti = $this->{$withModel}->getDataSource();\n\t\t\t\t} else {\n\t\t\t\t\t$dbMulti = $db;\n\t\t\t\t}\n\n\t\t\t\t$isUUID = !empty($this->{$join}->primaryKey) && $this->{$join}->_isUUIDField($this->{$join}->primaryKey);\n\n\t\t\t\t$newData = $newValues = $newJoins = array();\n\t\t\t\t$primaryAdded = false;\n\n\t\t\t\t$fields = array(\n\t\t\t\t\t$dbMulti->name($this->hasAndBelongsToMany[$assoc]['foreignKey']),\n\t\t\t\t\t$dbMulti->name($this->hasAndBelongsToMany[$assoc]['associationForeignKey'])\n\t\t\t\t);\n\n\t\t\t\t$idField = $db->name($this->{$join}->primaryKey);\n\t\t\t\tif ($isUUID && !in_array($idField, $fields)) {\n\t\t\t\t\t$fields[] = $idField;\n\t\t\t\t\t$primaryAdded = true;\n\t\t\t\t}\n\n\t\t\t\tforeach ((array)$data as $row) {\n\t\t\t\t\tif ((is_string($row) && (strlen($row) == 36 || strlen($row) == 16)) || is_numeric($row)) {\n\t\t\t\t\t\t$newJoins[] = $row;\n\t\t\t\t\t\t$values = array($id, $row);\n\t\t\t\t\t\tif ($isUUID && $primaryAdded) {\n\t\t\t\t\t\t\t$values[] = String::uuid();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$newValues[$row] = $values;\n\t\t\t\t\t\tunset($values);\n\t\t\t\t\t} elseif (isset($row[$this->hasAndBelongsToMany[$assoc]['associationForeignKey']])) {\n\t\t\t\t\t\tif (!empty($row[$this->{$join}->primaryKey])) {\n\t\t\t\t\t\t\t$newJoins[] = $row[$this->hasAndBelongsToMany[$assoc]['associationForeignKey']];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$newData[] = $row;\n\t\t\t\t\t} elseif (isset($row[$join]) && isset($row[$join][$this->hasAndBelongsToMany[$assoc]['associationForeignKey']])) {\n\t\t\t\t\t\tif (!empty($row[$join][$this->{$join}->primaryKey])) {\n\t\t\t\t\t\t\t$newJoins[] = $row[$join][$this->hasAndBelongsToMany[$assoc]['associationForeignKey']];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$newData[] = $row[$join];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t$keepExisting = $this->hasAndBelongsToMany[$assoc]['unique'] === 'keepExisting';\n\t\t\t\tif ($this->hasAndBelongsToMany[$assoc]['unique']) {\n\t\t\t\t\t$conditions = array(\n\t\t\t\t\t\t$join . '.' . $this->hasAndBelongsToMany[$assoc]['foreignKey'] => $id\n\t\t\t\t\t);\n\t\t\t\t\tif (!empty($this->hasAndBelongsToMany[$assoc]['conditions'])) {\n\t\t\t\t\t\t$conditions = array_merge($conditions, (array)$this->hasAndBelongsToMany[$assoc]['conditions']);\n\t\t\t\t\t}\n\t\t\t\t\t$associationForeignKey = $this->{$join}->alias . '.' . $this->hasAndBelongsToMany[$assoc]['associationForeignKey'];\n\t\t\t\t\t$links = $this->{$join}->find('all', array(\n\t\t\t\t\t\t'conditions' => $conditions,\n\t\t\t\t\t\t'recursive' => empty($this->hasAndBelongsToMany[$assoc]['conditions']) ? -1 : 0,\n\t\t\t\t\t\t'fields' => $associationForeignKey,\n\t\t\t\t\t));\n\n\t\t\t\t\t$oldLinks = Hash::extract($links, \"{n}.{$associationForeignKey}\");\n\t\t\t\t\tif (!empty($oldLinks)) {\n\t\t\t\t\t\tif ($keepExisting && !empty($newJoins)) {\n\t\t\t\t\t\t\t$conditions[$associationForeignKey] = array_diff($oldLinks, $newJoins);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$conditions[$associationForeignKey] = $oldLinks;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$dbMulti->delete($this->{$join}, $conditions);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!empty($newData)) {\n\t\t\t\t\tforeach ($newData as $data) {\n\t\t\t\t\t\t$data[$this->hasAndBelongsToMany[$assoc]['foreignKey']] = $id;\n\t\t\t\t\t\tif (empty($data[$this->{$join}->primaryKey])) {\n\t\t\t\t\t\t\t$this->{$join}->create();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$this->{$join}->save($data);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!empty($newValues)) {\n\t\t\t\t\tif ($keepExisting && !empty($links)) {\n\t\t\t\t\t\tforeach ($links as $link) {\n\t\t\t\t\t\t\t$oldJoin = $link[$join][$this->hasAndBelongsToMany[$assoc]['associationForeignKey']];\n\t\t\t\t\t\t\tif (!in_array($oldJoin, $newJoins)) {\n\t\t\t\t\t\t\t\t$conditions[$associationForeignKey] = $oldJoin;\n\t\t\t\t\t\t\t\t$db->delete($this->{$join}, $conditions);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tunset($newValues[$oldJoin]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$newValues = array_values($newValues);\n\t\t\t\t\t}\n\t\t\t\t\tif (!empty($newValues)) {\n\t\t\t\t\t\t$dbMulti->insertMulti($this->{$join}, $fields, $newValues);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n/**\n * Updates the counter cache of belongsTo associations after a save or delete operation\n *\n * @param array $keys Optional foreign key data, defaults to the information $this->data\n * @param boolean $created True if a new record was created, otherwise only associations with\n *   'counterScope' defined get updated\n * @return void\n */\n\tpublic function updateCounterCache($keys = array(), $created = false) {\n\t\t$keys = empty($keys) ? $this->data[$this->alias] : $keys;\n\t\t$keys['old'] = isset($keys['old']) ? $keys['old'] : array();\n\n\t\tforeach ($this->belongsTo as $parent => $assoc) {\n\t\t\tif (!empty($assoc['counterCache'])) {\n\t\t\t\tif (!is_array($assoc['counterCache'])) {\n\t\t\t\t\tif (isset($assoc['counterScope'])) {\n\t\t\t\t\t\t$assoc['counterCache'] = array($assoc['counterCache'] => $assoc['counterScope']);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$assoc['counterCache'] = array($assoc['counterCache'] => array());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t$foreignKey = $assoc['foreignKey'];\n\t\t\t\t$fkQuoted = $this->escapeField($assoc['foreignKey']);\n\n\t\t\t\tforeach ($assoc['counterCache'] as $field => $conditions) {\n\t\t\t\t\tif (!is_string($field)) {\n\t\t\t\t\t\t$field = Inflector::underscore($this->alias) . '_count';\n\t\t\t\t\t}\n\t\t\t\t\tif (!$this->{$parent}->hasField($field)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif ($conditions === true) {\n\t\t\t\t\t\t$conditions = array();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$conditions = (array)$conditions;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!array_key_exists($foreignKey, $keys)) {\n\t\t\t\t\t\t$keys[$foreignKey] = $this->field($foreignKey);\n\t\t\t\t\t}\n\t\t\t\t\t$recursive = (empty($conditions) ? -1 : 0);\n\n\t\t\t\t\tif (isset($keys['old'][$foreignKey])) {\n\t\t\t\t\t\tif ($keys['old'][$foreignKey] != $keys[$foreignKey]) {\n\t\t\t\t\t\t\t$conditions[$fkQuoted] = $keys['old'][$foreignKey];\n\t\t\t\t\t\t\t$count = intval($this->find('count', compact('conditions', 'recursive')));\n\n\t\t\t\t\t\t\t$this->{$parent}->updateAll(\n\t\t\t\t\t\t\t\tarray($field => $count),\n\t\t\t\t\t\t\t\tarray($this->{$parent}->escapeField() => $keys['old'][$foreignKey])\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$conditions[$fkQuoted] = $keys[$foreignKey];\n\n\t\t\t\t\tif ($recursive === 0) {\n\t\t\t\t\t\t$conditions = array_merge($conditions, (array)$conditions);\n\t\t\t\t\t}\n\t\t\t\t\t$count = intval($this->find('count', compact('conditions', 'recursive')));\n\n\t\t\t\t\t$this->{$parent}->updateAll(\n\t\t\t\t\t\tarray($field => $count),\n\t\t\t\t\t\tarray($this->{$parent}->escapeField() => $keys[$foreignKey])\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n/**\n * Helper method for `Model::updateCounterCache()`. Checks the fields to be updated for\n *\n * @param array $data The fields of the record that will be updated\n * @return array Returns updated foreign key values, along with an 'old' key containing the old\n *     values, or empty if no foreign keys are updated.\n */\n\tprotected function _prepareUpdateFields($data) {\n\t\t$foreignKeys = array();\n\t\tforeach ($this->belongsTo as $assoc => $info) {\n\t\t\tif ($info['counterCache']) {\n\t\t\t\t$foreignKeys[$assoc] = $info['foreignKey'];\n\t\t\t}\n\t\t}\n\t\t$included = array_intersect($foreignKeys, array_keys($data));\n\n\t\tif (empty($included) || empty($this->id)) {\n\t\t\treturn array();\n\t\t}\n\t\t$old = $this->find('first', array(\n\t\t\t'conditions' => array($this->alias . '.' . $this->primaryKey => $this->id),\n\t\t\t'fields' => array_values($included),\n\t\t\t'recursive' => -1\n\t\t));\n\t\treturn array_merge($data, array('old' => $old[$this->alias]));\n\t}\n\n/**\n * Backwards compatible passthrough method for:\n * saveMany(), validateMany(), saveAssociated() and validateAssociated()\n *\n * Saves multiple individual records for a single model; Also works with a single record, as well as\n * all its associated records.\n *\n * #### Options\n *\n * - `validate`: Set to false to disable validation, true to validate each record before saving,\n *   'first' to validate *all* records before any are saved (default),\n *   or 'only' to only validate the records, but not save them.\n * - `atomic`: If true (default), will attempt to save all records in a single transaction.\n *   Should be set to false if database/table does not support transactions.\n * - `fieldList`: Equivalent to the $fieldList parameter in Model::save().\n *   It should be an associate array with model name as key and array of fields as value. Eg.\n *   {{{\n *   array(\n *       'SomeModel' => array('field'),\n *       'AssociatedModel' => array('field', 'otherfield')\n *   )\n *   }}}\n * - `deep`: see saveMany/saveAssociated\n *\n * @param array $data Record data to save. This can be either a numerically-indexed array (for saving multiple\n *     records of the same type), or an array indexed by association name.\n * @param array $options Options to use when saving record data, See $options above.\n * @return mixed If atomic: True on success, or false on failure.\n *    Otherwise: array similar to the $data array passed, but values are set to true/false\n *    depending on whether each record saved successfully.\n * @link http://book.cakephp.org/2.0/en/models/saving-your-data.html#model-saveassociated-array-data-null-array-options-array\n * @link http://book.cakephp.org/2.0/en/models/saving-your-data.html#model-saveall-array-data-null-array-options-array\n */\n\tpublic function saveAll($data = array(), $options = array()) {\n\t\t$options = array_merge(array('validate' => 'first'), $options);\n\t\tif (Hash::numeric(array_keys($data))) {\n\t\t\tif ($options['validate'] === 'only') {\n\t\t\t\treturn $this->validateMany($data, $options);\n\t\t\t}\n\t\t\treturn $this->saveMany($data, $options);\n\t\t}\n\t\tif ($options['validate'] === 'only') {\n\t\t\treturn $this->validateAssociated($data, $options);\n\t\t}\n\t\treturn $this->saveAssociated($data, $options);\n\t}\n\n/**\n * Saves multiple individual records for a single model\n *\n * #### Options\n *\n * - `validate`: Set to false to disable validation, true to validate each record before saving,\n *   'first' to validate *all* records before any are saved (default),\n * - `atomic`: If true (default), will attempt to save all records in a single transaction.\n *   Should be set to false if database/table does not support transactions.\n * - `fieldList`: Equivalent to the $fieldList parameter in Model::save()\n * - `deep`: If set to true, all associated data will be saved as well.\n *\n * @param array $data Record data to save. This should be a numerically-indexed array\n * @param array $options Options to use when saving record data, See $options above.\n * @return mixed If atomic: True on success, or false on failure.\n *    Otherwise: array similar to the $data array passed, but values are set to true/false\n *    depending on whether each record saved successfully.\n * @link http://book.cakephp.org/2.0/en/models/saving-your-data.html#model-savemany-array-data-null-array-options-array\n */\n\tpublic function saveMany($data = null, $options = array()) {\n\t\tif (empty($data)) {\n\t\t\t$data = $this->data;\n\t\t}\n\n\t\t$options = array_merge(array('validate' => 'first', 'atomic' => true, 'deep' => false), $options);\n\t\t$this->validationErrors = $validationErrors = array();\n\n\t\tif (empty($data) && $options['validate'] !== false) {\n\t\t\t$result = $this->save($data, $options);\n\t\t\tif (!$options['atomic']) {\n\t\t\t\treturn array(!empty($result));\n\t\t\t}\n\t\t\treturn !empty($result);\n\t\t}\n\n\t\tif ($options['validate'] === 'first') {\n\t\t\t$validates = $this->validateMany($data, $options);\n\t\t\tif ((!$validates && $options['atomic']) || (!$options['atomic'] && in_array(false, $validates, true))) {\n\t\t\t\treturn $validates;\n\t\t\t}\n\t\t\t$options['validate'] = false;\n\t\t}\n\n\t\tif ($options['atomic']) {\n\t\t\t$db = $this->getDataSource();\n\t\t\t$transactionBegun = $db->begin();\n\t\t}\n\t\t$return = array();\n\t\tforeach ($data as $key => $record) {\n\t\t\t$validates = $this->create(null) !== null;\n\t\t\t$saved = false;\n\t\t\tif ($validates) {\n\t\t\t\tif ($options['deep']) {\n\t\t\t\t\t$saved = $this->saveAssociated($record, array_merge($options, array('atomic' => false)));\n\t\t\t\t} else {\n\t\t\t\t\t$saved = $this->save($record, $options);\n\t\t\t\t}\n\t\t\t}\n\t\t\t$validates = ($validates && ($saved === true || (is_array($saved) && !in_array(false, $saved, true))));\n\t\t\tif (!$validates) {\n\t\t\t\t$validationErrors[$key] = $this->validationErrors;\n\t\t\t}\n\t\t\tif (!$options['atomic']) {\n\t\t\t\t$return[$key] = $validates;\n\t\t\t} elseif (!$validates) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t$this->validationErrors = $validationErrors;\n\n\t\tif (!$options['atomic']) {\n\t\t\treturn $return;\n\t\t}\n\t\tif ($validates) {\n\t\t\tif ($transactionBegun) {\n\t\t\t\treturn $db->commit() !== false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t$db->rollback();\n\t\treturn false;\n\t}\n\n/**\n * Validates multiple individual records for a single model\n *\n * #### Options\n *\n * - `atomic`: If true (default), returns boolean. If false returns array.\n * - `fieldList`: Equivalent to the $fieldList parameter in Model::save()\n * - `deep`: If set to true, all associated data will be validated as well.\n *\n * Warning: This method could potentially change the passed argument `$data`,\n * If you do not want this to happen, make a copy of `$data` before passing it\n * to this method\n *\n * @param array $data Record data to validate. This should be a numerically-indexed array\n * @param array $options Options to use when validating record data (see above), See also $options of validates().\n * @return boolean|array If atomic: True on success, or false on failure.\n *    Otherwise: array similar to the $data array passed, but values are set to true/false\n *    depending on whether each record validated successfully.\n */\n\tpublic function validateMany(&$data, $options = array()) {\n\t\treturn $this->validator()->validateMany($data, $options);\n\t}\n\n/**\n * Saves a single record, as well as all its directly associated records.\n *\n * #### Options\n *\n * - `validate`: Set to `false` to disable validation, `true` to validate each record before saving,\n *   'first' to validate *all* records before any are saved(default),\n * - `atomic`: If true (default), will attempt to save all records in a single transaction.\n *   Should be set to false if database/table does not support transactions.\n * - `fieldList`: Equivalent to the $fieldList parameter in Model::save().\n *   It should be an associate array with model name as key and array of fields as value. Eg.\n *   {{{\n *   array(\n *       'SomeModel' => array('field'),\n *       'AssociatedModel' => array('field', 'otherfield')\n *   )\n *   }}}\n * - `deep`: If set to true, not only directly associated data is saved, but deeper nested associated data as well.\n *\n * @param array $data Record data to save. This should be an array indexed by association name.\n * @param array $options Options to use when saving record data, See $options above.\n * @return mixed If atomic: True on success, or false on failure.\n *    Otherwise: array similar to the $data array passed, but values are set to true/false\n *    depending on whether each record saved successfully.\n * @link http://book.cakephp.org/2.0/en/models/saving-your-data.html#model-saveassociated-array-data-null-array-options-array\n */\n\tpublic function saveAssociated($data = null, $options = array()) {\n\t\tif (empty($data)) {\n\t\t\t$data = $this->data;\n\t\t}\n\n\t\t$options = array_merge(array('validate' => 'first', 'atomic' => true, 'deep' => false), $options);\n\t\t$this->validationErrors = $validationErrors = array();\n\n\t\tif (empty($data) && $options['validate'] !== false) {\n\t\t\t$result = $this->save($data, $options);\n\t\t\tif (!$options['atomic']) {\n\t\t\t\treturn array(!empty($result));\n\t\t\t}\n\t\t\treturn !empty($result);\n\t\t}\n\n\t\tif ($options['validate'] === 'first') {\n\t\t\t$validates = $this->validateAssociated($data, $options);\n\t\t\tif ((!$validates && $options['atomic']) || (!$options['atomic'] && in_array(false, Hash::flatten($validates), true))) {\n\t\t\t\treturn $validates;\n\t\t\t}\n\t\t\t$options['validate'] = false;\n\t\t}\n\t\tif ($options['atomic']) {\n\t\t\t$db = $this->getDataSource();\n\t\t\t$transactionBegun = $db->begin();\n\t\t}\n\n\t\t$associations = $this->getAssociated();\n\t\t$return = array();\n\t\t$validates = true;\n\t\tforeach ($data as $association => $values) {\n\t\t\t$notEmpty = !empty($values[$association]) || (!isset($values[$association]) && !empty($values));\n\t\t\tif (isset($associations[$association]) && $associations[$association] === 'belongsTo' && $notEmpty) {\n\t\t\t\t$validates = $this->{$association}->create(null) !== null;\n\t\t\t\t$saved = false;\n\t\t\t\tif ($validates) {\n\t\t\t\t\tif ($options['deep']) {\n\t\t\t\t\t\t$saved = $this->{$association}->saveAssociated($values, array_merge($options, array('atomic' => false)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$saved = $this->{$association}->save($values, array_merge($options, array('atomic' => false)));\n\t\t\t\t\t}\n\t\t\t\t\t$validates = ($saved === true || (is_array($saved) && !in_array(false, $saved, true)));\n\t\t\t\t}\n\t\t\t\tif ($validates) {\n\t\t\t\t\t$key = $this->belongsTo[$association]['foreignKey'];\n\t\t\t\t\tif (isset($data[$this->alias])) {\n\t\t\t\t\t\t$data[$this->alias][$key] = $this->{$association}->id;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$data = array_merge(array($key => $this->{$association}->id), $data, array($key => $this->{$association}->id));\n\t\t\t\t\t}\n\t\t\t\t\t$options = $this->_addToWhiteList($key, $options);\n\t\t\t\t} else {\n\t\t\t\t\t$validationErrors[$association] = $this->{$association}->validationErrors;\n\t\t\t\t}\n\t\t\t\t$return[$association] = $validates;\n\t\t\t}\n\t\t}\n\t\tif ($validates && !($this->create(null) !== null && $this->save($data, $options))) {\n\t\t\t$validationErrors[$this->alias] = $this->validationErrors;\n\t\t\t$validates = false;\n\t\t}\n\t\t$return[$this->alias] = $validates;\n\n\t\tforeach ($data as $association => $values) {\n\t\t\tif (!$validates) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t$notEmpty = !empty($values[$association]) || (!isset($values[$association]) && !empty($values));\n\t\t\tif (isset($associations[$association]) && $notEmpty) {\n\t\t\t\t$type = $associations[$association];\n\t\t\t\t$key = $this->{$type}[$association]['foreignKey'];\n\t\t\t\tswitch ($type) {\n\t\t\t\t\tcase 'hasOne':\n\t\t\t\t\t\tif (isset($values[$association])) {\n\t\t\t\t\t\t\t$values[$association][$key] = $this->id;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$values = array_merge(array($key => $this->id), $values, array($key => $this->id));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$validates = $this->{$association}->create(null) !== null;\n\t\t\t\t\t\t$saved = false;\n\t\t\t\t\t\tif ($validates) {\n\t\t\t\t\t\t\t$options = $this->{$association}->_addToWhiteList($key, $options);\n\t\t\t\t\t\t\tif ($options['deep']) {\n\t\t\t\t\t\t\t\t$saved = $this->{$association}->saveAssociated($values, array_merge($options, array('atomic' => false)));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$saved = $this->{$association}->save($values, $options);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$validates = ($validates && ($saved === true || (is_array($saved) && !in_array(false, $saved, true))));\n\t\t\t\t\t\tif (!$validates) {\n\t\t\t\t\t\t\t$validationErrors[$association] = $this->{$association}->validationErrors;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$return[$association] = $validates;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'hasMany':\n\t\t\t\t\t\tforeach ($values as $i => $value) {\n\t\t\t\t\t\t\tif (isset($values[$i][$association])) {\n\t\t\t\t\t\t\t\t$values[$i][$association][$key] = $this->id;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$values[$i] = array_merge(array($key => $this->id), $value, array($key => $this->id));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$options = $this->{$association}->_addToWhiteList($key, $options);\n\t\t\t\t\t\t$_return = $this->{$association}->saveMany($values, array_merge($options, array('atomic' => false)));\n\t\t\t\t\t\tif (in_array(false, $_return, true)) {\n\t\t\t\t\t\t\t$validationErrors[$association] = $this->{$association}->validationErrors;\n\t\t\t\t\t\t\t$validates = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$return[$association] = $_return;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$this->validationErrors = $validationErrors;\n\n\t\tif (isset($validationErrors[$this->alias])) {\n\t\t\t$this->validationErrors = $validationErrors[$this->alias];\n\t\t\tunset($validationErrors[$this->alias]);\n\t\t\t$this->validationErrors = array_merge($this->validationErrors, $validationErrors);\n\t\t}\n\n\t\tif (!$options['atomic']) {\n\t\t\treturn $return;\n\t\t}\n\t\tif ($validates) {\n\t\t\tif ($transactionBegun) {\n\t\t\t\treturn $db->commit() !== false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t$db->rollback();\n\t\treturn false;\n\t}\n\n/**\n * Helper method for saveAll() and friends, to add foreign key to fieldlist\n *\n * @param string $key fieldname to be added to list\n * @param array $options\n * @return array $options\n */\n\tprotected function _addToWhiteList($key, $options) {\n\t\tif (empty($options['fieldList']) && $this->whitelist && !in_array($key, $this->whitelist)) {\n\t\t\t$options['fieldList'][$this->alias] = $this->whitelist;\n\t\t\t$options['fieldList'][$this->alias][] = $key;\n\t\t\treturn $options;\n\t\t}\n\t\tif (!empty($options['fieldList'][$this->alias]) && is_array($options['fieldList'][$this->alias])) {\n\t\t\t$options['fieldList'][$this->alias][] = $key;\n\t\t\treturn $options;\n\t\t}\n\t\tif (!empty($options['fieldList']) &&\n\t\t\tis_array($options['fieldList']) &&\n\t\t\tHash::dimensions($options['fieldList']) < 2\n\t\t) {\n\t\t\t$options['fieldList'][] = $key;\n\t\t}\n\t\treturn $options;\n\t}\n\n/**\n * Validates a single record, as well as all its directly associated records.\n *\n * #### Options\n *\n * - `atomic`: If true (default), returns boolean. If false returns array.\n * - `fieldList`: Equivalent to the $fieldList parameter in Model::save()\n * - `deep`: If set to true, not only directly associated data , but deeper nested associated data is validated as well.\n *\n * Warning: This method could potentially change the passed argument `$data`,\n * If you do not want this to happen, make a copy of `$data` before passing it\n * to this method\n *\n * @param array $data Record data to validate. This should be an array indexed by association name.\n * @param array $options Options to use when validating record data (see above), See also $options of validates().\n * @return array|boolean If atomic: True on success, or false on failure.\n *    Otherwise: array similar to the $data array passed, but values are set to true/false\n *    depending on whether each record validated successfully.\n */\n\tpublic function validateAssociated(&$data, $options = array()) {\n\t\treturn $this->validator()->validateAssociated($data, $options);\n\t}\n\n/**\n * Updates multiple model records based on a set of conditions.\n *\n * @param array $fields Set of fields and values, indexed by fields.\n *    Fields are treated as SQL snippets, to insert literal values manually escape your data.\n * @param mixed $conditions Conditions to match, true for all records\n * @return boolean True on success, false on failure\n * @link http://book.cakephp.org/2.0/en/models/saving-your-data.html#model-updateall-array-fields-array-conditions\n */\n\tpublic function updateAll($fields, $conditions = true) {\n\t\treturn $this->getDataSource()->update($this, $fields, null, $conditions);\n\t}\n\n/**\n * Removes record for given ID. If no ID is given, the current ID is used. Returns true on success.\n *\n * @param integer|string $id ID of record to delete\n * @param boolean $cascade Set to true to delete records that depend on this record\n * @return boolean True on success\n * @link http://book.cakephp.org/2.0/en/models/deleting-data.html\n */\n\tpublic function delete($id = null, $cascade = true) {\n\t\tif (!empty($id)) {\n\t\t\t$this->id = $id;\n\t\t}\n\t\t$id = $this->id;\n\n\t\t$event = new CakeEvent('Model.beforeDelete', $this, array($cascade));\n\t\tlist($event->break, $event->breakOn) = array(true, array(false, null));\n\t\t$this->getEventManager()->dispatch($event);\n\t\tif ($event->isStopped()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!$this->exists()) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$this->_deleteDependent($id, $cascade);\n\t\t$this->_deleteLinks($id);\n\t\t$this->id = $id;\n\n\t\tif (!empty($this->belongsTo)) {\n\t\t\tforeach ($this->belongsTo as $assoc) {\n\t\t\t\tif (empty($assoc['counterCache'])) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t$keys = $this->find('first', array(\n\t\t\t\t\t'fields' => $this->_collectForeignKeys(),\n\t\t\t\t\t'conditions' => array($this->alias . '.' . $this->primaryKey => $id),\n\t\t\t\t\t'recursive' => -1,\n\t\t\t\t\t'callbacks' => false\n\t\t\t\t));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!$this->getDataSource()->delete($this, array($this->alias . '.' . $this->primaryKey => $id))) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!empty($keys[$this->alias])) {\n\t\t\t$this->updateCounterCache($keys[$this->alias]);\n\t\t}\n\t\t$this->getEventManager()->dispatch(new CakeEvent('Model.afterDelete', $this));\n\t\t$this->_clearCache();\n\t\t$this->id = false;\n\t\treturn true;\n\t}\n\n/**\n * Cascades model deletes through associated hasMany and hasOne child records.\n *\n * @param string $id ID of record that was deleted\n * @param boolean $cascade Set to true to delete records that depend on this record\n * @return void\n */\n\tprotected function _deleteDependent($id, $cascade) {\n\t\tif ($cascade !== true) {\n\t\t\treturn;\n\t\t}\n\t\tif (!empty($this->__backAssociation)) {\n\t\t\t$savedAssociations = $this->__backAssociation;\n\t\t\t$this->__backAssociation = array();\n\t\t}\n\n\t\tforeach (array_merge($this->hasMany, $this->hasOne) as $assoc => $data) {\n\t\t\tif ($data['dependent'] !== true) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$model = $this->{$assoc};\n\n\t\t\tif ($data['foreignKey'] === false && $data['conditions'] && in_array($this->name, $model->getAssociated('belongsTo'))) {\n\t\t\t\t$model->recursive = 0;\n\t\t\t\t$conditions = array($this->escapeField(null, $this->name) => $id);\n\t\t\t} else {\n\t\t\t\t$model->recursive = -1;\n\t\t\t\t$conditions = array($model->escapeField($data['foreignKey']) => $id);\n\t\t\t\tif ($data['conditions']) {\n\t\t\t\t\t$conditions = array_merge((array)$data['conditions'], $conditions);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isset($data['exclusive']) && $data['exclusive']) {\n\t\t\t\t$model->deleteAll($conditions);\n\t\t\t} else {\n\t\t\t\t$records = $model->find('all', array(\n\t\t\t\t\t'conditions' => $conditions, 'fields' => $model->primaryKey\n\t\t\t\t));\n\n\t\t\t\tif (!empty($records)) {\n\t\t\t\t\tforeach ($records as $record) {\n\t\t\t\t\t\t$model->delete($record[$model->alias][$model->primaryKey]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (isset($savedAssociations)) {\n\t\t\t$this->__backAssociation = $savedAssociations;\n\t\t}\n\t}\n\n/**\n * Cascades model deletes through HABTM join keys.\n *\n * @param string $id ID of record that was deleted\n * @return void\n */\n\tprotected function _deleteLinks($id) {\n\t\tforeach ($this->hasAndBelongsToMany as $data) {\n\t\t\tlist(, $joinModel) = pluginSplit($data['with']);\n\t\t\t$records = $this->{$joinModel}->find('all', array(\n\t\t\t\t'conditions' => array($this->{$joinModel}->escapeField($data['foreignKey']) => $id),\n\t\t\t\t'fields' => $this->{$joinModel}->primaryKey,\n\t\t\t\t'recursive' => -1,\n\t\t\t\t'callbacks' => false\n\t\t\t));\n\t\t\tif (!empty($records)) {\n\t\t\t\tforeach ($records as $record) {\n\t\t\t\t\t$this->{$joinModel}->delete($record[$this->{$joinModel}->alias][$this->{$joinModel}->primaryKey]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n/**\n * Deletes multiple model records based on a set of conditions.\n *\n * @param mixed $conditions Conditions to match\n * @param boolean $cascade Set to true to delete records that depend on this record\n * @param boolean $callbacks Run callbacks\n * @return boolean True on success, false on failure\n * @link http://book.cakephp.org/2.0/en/models/deleting-data.html#deleteall\n */\n\tpublic function deleteAll($conditions, $cascade = true, $callbacks = false) {\n\t\tif (empty($conditions)) {\n\t\t\treturn false;\n\t\t}\n\t\t$db = $this->getDataSource();\n\n\t\tif (!$cascade && !$callbacks) {\n\t\t\treturn $db->delete($this, $conditions);\n\t\t}\n\t\t$ids = $this->find('all', array_merge(array(\n\t\t\t'fields' => \"{$this->alias}.{$this->primaryKey}\",\n\t\t\t'recursive' => 0), compact('conditions'))\n\t\t);\n\t\tif ($ids === false || $ids === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$ids = Hash::extract($ids, \"{n}.{$this->alias}.{$this->primaryKey}\");\n\t\tif (empty($ids)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ($callbacks) {\n\t\t\t$_id = $this->id;\n\t\t\t$result = true;\n\t\t\tforeach ($ids as $id) {\n\t\t\t\t$result = $result && $this->delete($id, $cascade);\n\t\t\t}\n\t\t\t$this->id = $_id;\n\t\t\treturn $result;\n\t\t}\n\n\t\tforeach ($ids as $id) {\n\t\t\t$this->_deleteLinks($id);\n\t\t\tif ($cascade) {\n\t\t\t\t$this->_deleteDependent($id, $cascade);\n\t\t\t}\n\t\t}\n\t\treturn $db->delete($this, array($this->alias . '.' . $this->primaryKey => $ids));\n\t}\n\n/**\n * Collects foreign keys from associations.\n *\n * @param string $type\n * @return array\n */\n\tprotected function _collectForeignKeys($type = 'belongsTo') {\n\t\t$result = array();\n\n\t\tforeach ($this->{$type} as $assoc => $data) {\n\t\t\tif (isset($data['foreignKey']) && is_string($data['foreignKey'])) {\n\t\t\t\t$result[$assoc] = $data['foreignKey'];\n\t\t\t}\n\t\t}\n\t\treturn $result;\n\t}\n\n/**\n * Returns true if a record with particular ID exists.\n *\n * If $id is not passed it calls `Model::getID()` to obtain the current record ID,\n * and then performs a `Model::find('count')` on the currently configured datasource\n * to ascertain the existence of the record in persistent storage.\n *\n * @param integer|string $id ID of record to check for existence\n * @return boolean True if such a record exists\n */\n\tpublic function exists($id = null) {\n\t\tif ($id === null) {\n\t\t\t$id = $this->getID();\n\t\t}\n\t\tif ($id === false) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (bool)$this->find('count', array(\n\t\t\t'conditions' => array(\n\t\t\t\t$this->alias . '.' . $this->primaryKey => $id\n\t\t\t),\n\t\t\t'recursive' => -1,\n\t\t\t'callbacks' => false\n\t\t));\n\t}\n\n/**\n * Returns true if a record that meets given conditions exists.\n *\n * @param array $conditions SQL conditions array\n * @return boolean True if such a record exists\n */\n\tpublic function hasAny($conditions = null) {\n\t\treturn (bool)$this->find('count', array('conditions' => $conditions, 'recursive' => -1));\n\t}\n\n/**\n * Queries the datasource and returns a result set array.\n *\n * Used to perform find operations, where the first argument is type of find operation to perform\n * (all / first / count / neighbors / list / threaded),\n * second parameter options for finding ( indexed array, including: 'conditions', 'limit',\n * 'recursive', 'page', 'fields', 'offset', 'order', 'callbacks')\n *\n * Eg:\n * {{{\n * $model->find('all', array(\n *   'conditions' => array('name' => 'Thomas Anderson'),\n *   'fields' => array('name', 'email'),\n *   'order' => 'field3 DESC',\n *   'recursive' => 2,\n *   'group' => 'type',\n *   'callbacks' => false,\n * ));\n * }}}\n *\n * In addition to the standard query keys above, you can provide Datasource, and behavior specific\n * keys. For example, when using a SQL based datasource you can use the joins key to specify additional\n * joins that should be part of the query.\n *\n * {{{\n * $model->find('all', array(\n *   'conditions' => array('name' => 'Thomas Anderson'),\n *   'joins' => array(\n *     array(\n *       'alias' => 'Thought',\n *       'table' => 'thoughts',\n *       'type' => 'LEFT',\n *       'conditions' => '`Thought`.`person_id` = `Person`.`id`'\n *     )\n *   )\n * ));\n * }}}\n *\n * ### Disabling callbacks\n *\n * The `callbacks` key allows you to disable or specify the callbacks that should be run. To\n * disable beforeFind & afterFind callbacks set `'callbacks' => false` in your options. You can\n * also set the callbacks option to 'before' or 'after' to enable only the specified callback.\n *\n * ### Adding new find types\n *\n * Behaviors and find types can also define custom finder keys which are passed into find().\n * See the documentation for custom find types\n * (http://book.cakephp.org/2.0/en/models/retrieving-your-data.html#creating-custom-find-types)\n * for how to implement custom find types.\n *\n * Specifying 'fields' for notation 'list':\n *\n * - If no fields are specified, then 'id' is used for key and 'model->displayField' is used for value.\n * - If a single field is specified, 'id' is used for key and specified field is used for value.\n * - If three fields are specified, they are used (in order) for key, value and group.\n * - Otherwise, first and second fields are used for key and value.\n *\n * Note: find(list) + database views have issues with MySQL 5.0. Try upgrading to MySQL 5.1 if you\n * have issues with database views.\n *\n * Note: find(count) has its own return values.\n *\n * @param string $type Type of find operation (all / first / count / neighbors / list / threaded)\n * @param array $query Option fields (conditions / fields / joins / limit / offset / order / page / group / callbacks)\n * @return array Array of records, or Null on failure.\n * @link http://book.cakephp.org/2.0/en/models/retrieving-your-data.html\n */\n\tpublic function find($type = 'first', $query = array()) {\n\t\t$this->findQueryType = $type;\n\t\t$this->id = $this->getID();\n\n\t\t$query = $this->buildQuery($type, $query);\n\t\tif (is_null($query)) {\n\t\t\treturn null;\n\t\t}\n\n\t\t$results = $this->getDataSource()->read($this, $query);\n\t\t$this->resetAssociations();\n\n\t\tif ($query['callbacks'] === true || $query['callbacks'] === 'after') {\n\t\t\t$results = $this->_filterResults($results);\n\t\t}\n\n\t\t$this->findQueryType = null;\n\n\t\tif ($type === 'all') {\n\t\t\treturn $results;\n\t\t}\n\n\t\tif ($this->findMethods[$type] === true) {\n\t\t\treturn $this->{'_find' . ucfirst($type)}('after', $query, $results);\n\t\t}\n\t}\n\n/**\n * Builds the query array that is used by the data source to generate the query to fetch the data.\n *\n * @param string $type Type of find operation (all / first / count / neighbors / list / threaded)\n * @param array $query Option fields (conditions / fields / joins / limit / offset / order / page / group / callbacks)\n * @return array Query array or null if it could not be build for some reasons\n * @see Model::find()\n */\n\tpublic function buildQuery($type = 'first', $query = array()) {\n\t\t$query = array_merge(\n\t\t\tarray(\n\t\t\t\t'conditions' => null, 'fields' => null, 'joins' => array(), 'limit' => null,\n\t\t\t\t'offset' => null, 'order' => null, 'page' => 1, 'group' => null, 'callbacks' => true,\n\t\t\t),\n\t\t\t(array)$query\n\t\t);\n\n\t\tif ($type !== 'all' && $this->findMethods[$type] === true) {\n\t\t\t$query = $this->{'_find' . ucfirst($type)}('before', $query);\n\t\t}\n\n\t\tif (!is_numeric($query['page']) || intval($query['page']) < 1) {\n\t\t\t$query['page'] = 1;\n\t\t}\n\t\tif ($query['page'] > 1 && !empty($query['limit'])) {\n\t\t\t$query['offset'] = ($query['page'] - 1) * $query['limit'];\n\t\t}\n\t\tif ($query['order'] === null && $this->order !== null) {\n\t\t\t$query['order'] = $this->order;\n\t\t}\n\t\t$query['order'] = array($query['order']);\n\n\t\tif ($query['callbacks'] === true || $query['callbacks'] === 'before') {\n\t\t\t$event = new CakeEvent('Model.beforeFind', $this, array($query));\n\t\t\tlist($event->break, $event->breakOn, $event->modParams) = array(true, array(false, null), 0);\n\t\t\t$this->getEventManager()->dispatch($event);\n\t\t\tif ($event->isStopped()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t$query = $event->result === true ? $event->data[0] : $event->result;\n\t\t}\n\n\t\treturn $query;\n\t}\n\n/**\n * Handles the before/after filter logic for find('first') operations. Only called by Model::find().\n *\n * @param string $state Either \"before\" or \"after\"\n * @param array $query\n * @param array $results\n * @return array\n * @see Model::find()\n */\n\tprotected function _findFirst($state, $query, $results = array()) {\n\t\tif ($state === 'before') {\n\t\t\t$query['limit'] = 1;\n\t\t\treturn $query;\n\t\t} elseif ($state === 'after') {\n\t\t\tif (empty($results[0])) {\n\t\t\t\treturn array();\n\t\t\t}\n\t\t\treturn $results[0];\n\t\t}\n\t}\n\n/**\n * Handles the before/after filter logic for find('count') operations. Only called by Model::find().\n *\n * @param string $state Either \"before\" or \"after\"\n * @param array $query\n * @param array $results\n * @return integer The number of records found, or false\n * @see Model::find()\n */\n\tprotected function _findCount($state, $query, $results = array()) {\n\t\tif ($state === 'before') {\n\t\t\tif (!empty($query['type']) && isset($this->findMethods[$query['type']]) && $query['type'] !== 'count') {\n\t\t\t\t$query['operation'] = 'count';\n\t\t\t\t$query = $this->{'_find' . ucfirst($query['type'])}('before', $query);\n\t\t\t}\n\t\t\t$db = $this->getDataSource();\n\t\t\t$query['order'] = false;\n\t\t\tif (!method_exists($db, 'calculate')) {\n\t\t\t\treturn $query;\n\t\t\t}\n\t\t\tif (!empty($query['fields']) && is_array($query['fields'])) {\n\t\t\t\tif (!preg_match('/^count/i', current($query['fields']))) {\n\t\t\t\t\tunset($query['fields']);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (empty($query['fields'])) {\n\t\t\t\t$query['fields'] = $db->calculate($this, 'count');\n\t\t\t} elseif (method_exists($db, 'expression') && is_string($query['fields']) && !preg_match('/count/i', $query['fields'])) {\n\t\t\t\t$query['fields'] = $db->calculate($this, 'count', array(\n\t\t\t\t\t$db->expression($query['fields']), 'count'\n\t\t\t\t));\n\t\t\t}\n\t\t\treturn $query;\n\t\t} elseif ($state === 'after') {\n\t\t\tforeach (array(0, $this->alias) as $key) {\n\t\t\t\tif (isset($results[0][$key]['count'])) {\n\t\t\t\t\tif ($query['group']) {\n\t\t\t\t\t\treturn count($results);\n\t\t\t\t\t}\n\t\t\t\t\treturn intval($results[0][$key]['count']);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n/**\n * Handles the before/after filter logic for find('list') operations. Only called by Model::find().\n *\n * @param string $state Either \"before\" or \"after\"\n * @param array $query\n * @param array $results\n * @return array Key/value pairs of primary keys/display field values of all records found\n * @see Model::find()\n */\n\tprotected function _findList($state, $query, $results = array()) {\n\t\tif ($state === 'before') {\n\t\t\tif (empty($query['fields'])) {\n\t\t\t\t$query['fields'] = array(\"{$this->alias}.{$this->primaryKey}\", \"{$this->alias}.{$this->displayField}\");\n\t\t\t\t$list = array(\"{n}.{$this->alias}.{$this->primaryKey}\", \"{n}.{$this->alias}.{$this->displayField}\", null);\n\t\t\t} else {\n\t\t\t\tif (!is_array($query['fields'])) {\n\t\t\t\t\t$query['fields'] = String::tokenize($query['fields']);\n\t\t\t\t}\n\n\t\t\t\tif (count($query['fields']) === 1) {\n\t\t\t\t\tif (strpos($query['fields'][0], '.') === false) {\n\t\t\t\t\t\t$query['fields'][0] = $this->alias . '.' . $query['fields'][0];\n\t\t\t\t\t}\n\n\t\t\t\t\t$list = array(\"{n}.{$this->alias}.{$this->primaryKey}\", '{n}.' . $query['fields'][0], null);\n\t\t\t\t\t$query['fields'] = array(\"{$this->alias}.{$this->primaryKey}\", $query['fields'][0]);\n\t\t\t\t} elseif (count($query['fields']) === 3) {\n\t\t\t\t\tfor ($i = 0; $i < 3; $i++) {\n\t\t\t\t\t\tif (strpos($query['fields'][$i], '.') === false) {\n\t\t\t\t\t\t\t$query['fields'][$i] = $this->alias . '.' . $query['fields'][$i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t$list = array('{n}.' . $query['fields'][0], '{n}.' . $query['fields'][1], '{n}.' . $query['fields'][2]);\n\t\t\t\t} else {\n\t\t\t\t\tfor ($i = 0; $i < 2; $i++) {\n\t\t\t\t\t\tif (strpos($query['fields'][$i], '.') === false) {\n\t\t\t\t\t\t\t$query['fields'][$i] = $this->alias . '.' . $query['fields'][$i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t$list = array('{n}.' . $query['fields'][0], '{n}.' . $query['fields'][1], null);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isset($query['recursive']) || $query['recursive'] === null) {\n\t\t\t\t$query['recursive'] = -1;\n\t\t\t}\n\t\t\tlist($query['list']['keyPath'], $query['list']['valuePath'], $query['list']['groupPath']) = $list;\n\t\t\treturn $query;\n\t\t} elseif ($state === 'after') {\n\t\t\tif (empty($results)) {\n\t\t\t\treturn array();\n\t\t\t}\n\t\t\treturn Hash::combine($results, $query['list']['keyPath'], $query['list']['valuePath'], $query['list']['groupPath']);\n\t\t}\n\t}\n\n/**\n * Detects the previous field's value, then uses logic to find the 'wrapping'\n * rows and return them.\n *\n * @param string $state Either \"before\" or \"after\"\n * @param array $query\n * @param array $results\n * @return array\n */\n\tprotected function _findNeighbors($state, $query, $results = array()) {\n\t\tif ($state === 'before') {\n\t\t\textract($query);\n\t\t\t$conditions = (array)$conditions;\n\t\t\tif (isset($field) && isset($value)) {\n\t\t\t\tif (strpos($field, '.') === false) {\n\t\t\t\t\t$field = $this->alias . '.' . $field;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$field = $this->alias . '.' . $this->primaryKey;\n\t\t\t\t$value = $this->id;\n\t\t\t}\n\t\t\t$query['conditions'] = array_merge($conditions, array($field . ' <' => $value));\n\t\t\t$query['order'] = $field . ' DESC';\n\t\t\t$query['limit'] = 1;\n\t\t\t$query['field'] = $field;\n\t\t\t$query['value'] = $value;\n\t\t\treturn $query;\n\t\t} elseif ($state === 'after') {\n\t\t\textract($query);\n\t\t\tunset($query['conditions'][$field . ' <']);\n\t\t\t$return = array();\n\t\t\tif (isset($results[0])) {\n\t\t\t\t$prevVal = Hash::get($results[0], $field);\n\t\t\t\t$query['conditions'][$field . ' >='] = $prevVal;\n\t\t\t\t$query['conditions'][$field . ' !='] = $value;\n\t\t\t\t$query['limit'] = 2;\n\t\t\t} else {\n\t\t\t\t$return['prev'] = null;\n\t\t\t\t$query['conditions'][$field . ' >'] = $value;\n\t\t\t\t$query['limit'] = 1;\n\t\t\t}\n\t\t\t$query['order'] = $field . ' ASC';\n\t\t\t$neighbors = $this->find('all', $query);\n\t\t\tif (!array_key_exists('prev', $return)) {\n\t\t\t\t$return['prev'] = isset($neighbors[0]) ? $neighbors[0] : null;\n\t\t\t}\n\t\t\tif (count($neighbors) === 2) {\n\t\t\t\t$return['next'] = $neighbors[1];\n\t\t\t} elseif (count($neighbors) === 1 && !$return['prev']) {\n\t\t\t\t$return['next'] = $neighbors[0];\n\t\t\t} else {\n\t\t\t\t$return['next'] = null;\n\t\t\t}\n\t\t\treturn $return;\n\t\t}\n\t}\n\n/**\n * In the event of ambiguous results returned (multiple top level results, with different parent_ids)\n * top level results with different parent_ids to the first result will be dropped\n *\n * @param string $state\n * @param mixed $query\n * @param array $results\n * @return array Threaded results\n */\n\tprotected function _findThreaded($state, $query, $results = array()) {\n\t\tif ($state === 'before') {\n\t\t\treturn $query;\n\t\t} elseif ($state === 'after') {\n\t\t\t$parent = 'parent_id';\n\t\t\tif (isset($query['parent'])) {\n\t\t\t\t$parent = $query['parent'];\n\t\t\t}\n\t\t\treturn Hash::nest($results, array(\n\t\t\t\t'idPath' => '{n}.' . $this->alias . '.' . $this->primaryKey,\n\t\t\t\t'parentPath' => '{n}.' . $this->alias . '.' . $parent\n\t\t\t));\n\t\t}\n\t}\n\n/**\n * Passes query results through model and behavior afterFilter() methods.\n *\n * @param array $results Results to filter\n * @param boolean $primary If this is the primary model results (results from model where the find operation was performed)\n * @return array Set of filtered results\n */\n\tprotected function _filterResults($results, $primary = true) {\n\t\t$event = new CakeEvent('Model.afterFind', $this, array($results, $primary));\n\t\t$event->modParams = 0;\n\t\t$this->getEventManager()->dispatch($event);\n\t\treturn $event->result;\n\t}\n\n/**\n * This resets the association arrays for the model back\n * to those originally defined in the model. Normally called at the end\n * of each call to Model::find()\n *\n * @return boolean Success\n */\n\tpublic function resetAssociations() {\n\t\tif (!empty($this->__backAssociation)) {\n\t\t\tforeach ($this->_associations as $type) {\n\t\t\t\tif (isset($this->__backAssociation[$type])) {\n\t\t\t\t\t$this->{$type} = $this->__backAssociation[$type];\n\t\t\t\t}\n\t\t\t}\n\t\t\t$this->__backAssociation = array();\n\t\t}\n\n\t\tforeach ($this->_associations as $type) {\n\t\t\tforeach ($this->{$type} as $key => $name) {\n\t\t\t\tif (property_exists($this, $key) && !empty($this->{$key}->__backAssociation)) {\n\t\t\t\t\t$this->{$key}->resetAssociations();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$this->__backAssociation = array();\n\t\treturn true;\n\t}\n\n/**\n * Returns false if any fields passed match any (by default, all if $or = false) of their matching values.\n *\n * @param array $fields Field/value pairs to search (if no values specified, they are pulled from $this->data)\n * @param boolean $or If false, all fields specified must match in order for a false return value\n * @return boolean False if any records matching any fields are found\n */\n\tpublic function isUnique($fields, $or = true) {\n\t\tif (!is_array($fields)) {\n\t\t\t$fields = func_get_args();\n\t\t\tif (is_bool($fields[count($fields) - 1])) {\n\t\t\t\t$or = $fields[count($fields) - 1];\n\t\t\t\tunset($fields[count($fields) - 1]);\n\t\t\t}\n\t\t}\n\n\t\tforeach ($fields as $field => $value) {\n\t\t\tif (is_numeric($field)) {\n\t\t\t\tunset($fields[$field]);\n\n\t\t\t\t$field = $value;\n\t\t\t\t$value = null;\n\t\t\t\tif (isset($this->data[$this->alias][$field])) {\n\t\t\t\t\t$value = $this->data[$this->alias][$field];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (strpos($field, '.') === false) {\n\t\t\t\tunset($fields[$field]);\n\t\t\t\t$fields[$this->alias . '.' . $field] = $value;\n\t\t\t}\n\t\t}\n\t\tif ($or) {\n\t\t\t$fields = array('or' => $fields);\n\t\t}\n\t\tif (!empty($this->id)) {\n\t\t\t$fields[$this->alias . '.' . $this->primaryKey . ' !='] = $this->id;\n\t\t}\n\t\treturn !$this->find('count', array('conditions' => $fields, 'recursive' => -1));\n\t}\n\n/**\n * Returns a resultset for a given SQL statement. Custom SQL queries should be performed with this method.\n *\n * @param string $sql SQL statement\n * @param boolean|array $params Either a boolean to control query caching or an array of parameters\n *    for use with prepared statement placeholders.\n * @param boolean $cache If $params is provided, a boolean flag for enabling/disabled\n *    query caching.\n * @return mixed Resultset array or boolean indicating success / failure depending on the query executed\n * @link http://book.cakephp.org/2.0/en/models/retrieving-your-data.html#model-query\n */\n\tpublic function query($sql) {\n\t\t$params = func_get_args();\n\t\t$db = $this->getDataSource();\n\t\treturn call_user_func_array(array(&$db, 'query'), $params);\n\t}\n\n/**\n * Returns true if all fields pass validation. Will validate hasAndBelongsToMany associations\n * that use the 'with' key as well. Since _saveMulti is incapable of exiting a save operation.\n *\n * Will validate the currently set data. Use Model::set() or Model::create() to set the active data.\n *\n * @param array $options An optional array of custom options to be made available in the beforeValidate callback\n * @return boolean True if there are no errors\n */\n\tpublic function validates($options = array()) {\n\t\treturn $this->validator()->validates($options);\n\t}\n\n/**\n * Returns an array of fields that have failed validation. On the current model.\n *\n * @param string $options An optional array of custom options to be made available in the beforeValidate callback\n * @return array Array of invalid fields\n * @see Model::validates()\n */\n\tpublic function invalidFields($options = array()) {\n\t\treturn $this->validator()->errors($options);\n\t}\n\n/**\n * Marks a field as invalid, optionally setting the name of validation\n * rule (in case of multiple validation for field) that was broken.\n *\n * @param string $field The name of the field to invalidate\n * @param mixed $value Name of validation rule that was not failed, or validation message to\n *    be returned. If no validation key is provided, defaults to true.\n * @return void\n */\n\tpublic function invalidate($field, $value = true) {\n\t\t$this->validator()->invalidate($field, $value);\n\t}\n\n/**\n * Returns true if given field name is a foreign key in this model.\n *\n * @param string $field Returns true if the input string ends in \"_id\"\n * @return boolean True if the field is a foreign key listed in the belongsTo array.\n */\n\tpublic function isForeignKey($field) {\n\t\t$foreignKeys = array();\n\t\tif (!empty($this->belongsTo)) {\n\t\t\tforeach ($this->belongsTo as $data) {\n\t\t\t\t$foreignKeys[] = $data['foreignKey'];\n\t\t\t}\n\t\t}\n\t\treturn in_array($field, $foreignKeys);\n\t}\n\n/**\n * Escapes the field name and prepends the model name. Escaping is done according to the\n * current database driver's rules.\n *\n * @param string $field Field to escape (e.g: id)\n * @param string $alias Alias for the model (e.g: Post)\n * @return string The name of the escaped field for this Model (i.e. id becomes `Post`.`id`).\n */\n\tpublic function escapeField($field = null, $alias = null) {\n\t\tif (empty($alias)) {\n\t\t\t$alias = $this->alias;\n\t\t}\n\t\tif (empty($field)) {\n\t\t\t$field = $this->primaryKey;\n\t\t}\n\t\t$db = $this->getDataSource();\n\t\tif (strpos($field, $db->name($alias) . '.') === 0) {\n\t\t\treturn $field;\n\t\t}\n\t\treturn $db->name($alias . '.' . $field);\n\t}\n\n/**\n * Returns the current record's ID\n *\n * @param integer $list Index on which the composed ID is located\n * @return mixed The ID of the current record, false if no ID\n */\n\tpublic function getID($list = 0) {\n\t\tif (empty($this->id) || (is_array($this->id) && isset($this->id[0]) && empty($this->id[0]))) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!is_array($this->id)) {\n\t\t\treturn $this->id;\n\t\t}\n\t\tif (isset($this->id[$list]) && !empty($this->id[$list])) {\n\t\t\treturn $this->id[$list];\n\t\t}\n\t\tif (isset($this->id[$list])) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn current($this->id);\n\t}\n\n/**\n * Returns the ID of the last record this model inserted.\n *\n * @return mixed Last inserted ID\n */\n\tpublic function getLastInsertID() {\n\t\treturn $this->getInsertID();\n\t}\n\n/**\n * Returns the ID of the last record this model inserted.\n *\n * @return mixed Last inserted ID\n */\n\tpublic function getInsertID() {\n\t\treturn $this->_insertID;\n\t}\n\n/**\n * Sets the ID of the last record this model inserted\n *\n * @param integer|string $id Last inserted ID\n * @return void\n */\n\tpublic function setInsertID($id) {\n\t\t$this->_insertID = $id;\n\t}\n\n/**\n * Returns the number of rows returned from the last query.\n *\n * @return integer Number of rows\n */\n\tpublic function getNumRows() {\n\t\treturn $this->getDataSource()->lastNumRows();\n\t}\n\n/**\n * Returns the number of rows affected by the last query.\n *\n * @return integer Number of rows\n */\n\tpublic function getAffectedRows() {\n\t\treturn $this->getDataSource()->lastAffected();\n\t}\n\n/**\n * Sets the DataSource to which this model is bound.\n *\n * @param string $dataSource The name of the DataSource, as defined in app/Config/database.php\n * @return void\n * @throws MissingConnectionException\n */\n\tpublic function setDataSource($dataSource = null) {\n\t\t$oldConfig = $this->useDbConfig;\n\n\t\tif ($dataSource) {\n\t\t\t$this->useDbConfig = $dataSource;\n\t\t}\n\t\t$db = ConnectionManager::getDataSource($this->useDbConfig);\n\t\tif (!empty($oldConfig) && isset($db->config['prefix'])) {\n\t\t\t$oldDb = ConnectionManager::getDataSource($oldConfig);\n\n\t\t\tif (!isset($this->tablePrefix) || (!isset($oldDb->config['prefix']) || $this->tablePrefix == $oldDb->config['prefix'])) {\n\t\t\t\t$this->tablePrefix = $db->config['prefix'];\n\t\t\t}\n\t\t} elseif (isset($db->config['prefix'])) {\n\t\t\t$this->tablePrefix = $db->config['prefix'];\n\t\t}\n\n\t\t$this->schemaName = $db->getSchemaName();\n\t}\n\n/**\n * Gets the DataSource to which this model is bound.\n *\n * @return DataSource A DataSource object\n */\n\tpublic function getDataSource() {\n\t\tif (!$this->_sourceConfigured && $this->useTable !== false) {\n\t\t\t$this->_sourceConfigured = true;\n\t\t\t$this->setSource($this->useTable);\n\t\t}\n\t\treturn ConnectionManager::getDataSource($this->useDbConfig);\n\t}\n\n/**\n * Get associations\n *\n * @return array\n */\n\tpublic function associations() {\n\t\treturn $this->_associations;\n\t}\n\n/**\n * Gets all the models with which this model is associated.\n *\n * @param string $type Only result associations of this type\n * @return array Associations\n */\n\tpublic function getAssociated($type = null) {\n\t\tif (!$type) {\n\t\t\t$associated = array();\n\t\t\tforeach ($this->_associations as $assoc) {\n\t\t\t\tif (!empty($this->{$assoc})) {\n\t\t\t\t\t$models = array_keys($this->{$assoc});\n\t\t\t\t\tforeach ($models as $m) {\n\t\t\t\t\t\t$associated[$m] = $assoc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $associated;\n\t\t}\n\t\tif (in_array($type, $this->_associations)) {\n\t\t\tif (empty($this->{$type})) {\n\t\t\t\treturn array();\n\t\t\t}\n\t\t\treturn array_keys($this->{$type});\n\t\t}\n\n\t\t$assoc = array_merge(\n\t\t\t$this->hasOne,\n\t\t\t$this->hasMany,\n\t\t\t$this->belongsTo,\n\t\t\t$this->hasAndBelongsToMany\n\t\t);\n\t\tif (array_key_exists($type, $assoc)) {\n\t\t\tforeach ($this->_associations as $a) {\n\t\t\t\tif (isset($this->{$a}[$type])) {\n\t\t\t\t\t$assoc[$type]['association'] = $a;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $assoc[$type];\n\t\t}\n\t\treturn null;\n\t}\n\n/**\n * Gets the name and fields to be used by a join model. This allows specifying join fields\n * in the association definition.\n *\n * @param string|array $assoc The model to be joined\n * @param array $keys Any join keys which must be merged with the keys queried\n * @return array\n */\n\tpublic function joinModel($assoc, $keys = array()) {\n\t\tif (is_string($assoc)) {\n\t\t\tlist(, $assoc) = pluginSplit($assoc);\n\t\t\treturn array($assoc, array_keys($this->{$assoc}->schema()));\n\t\t}\n\t\tif (is_array($assoc)) {\n\t\t\t$with = key($assoc);\n\t\t\treturn array($with, array_unique(array_merge($assoc[$with], $keys)));\n\t\t}\n\t\ttrigger_error(\n\t\t\t__d('cake_dev', 'Invalid join model settings in %s. The association parameter has the wrong type, expecting a string or array, but was passed type: %s', $this->alias, gettype($assoc)),\n\t\t\tE_USER_WARNING\n\t\t);\n\t}\n\n/**\n * Called before each find operation. Return false if you want to halt the find\n * call, otherwise return the (modified) query data.\n *\n * @param array $queryData Data used to execute this query, i.e. conditions, order, etc.\n * @return mixed true if the operation should continue, false if it should abort; or, modified\n *               $queryData to continue with new $queryData\n * @link http://book.cakephp.org/2.0/en/models/callback-methods.html#beforefind\n */\n\tpublic function beforeFind($queryData) {\n\t\treturn true;\n\t}\n\n/**\n * Called after each find operation. Can be used to modify any results returned by find().\n * Return value should be the (modified) results.\n *\n * @param mixed $results The results of the find operation\n * @param boolean $primary Whether this model is being queried directly (vs. being queried as an association)\n * @return mixed Result of the find operation\n * @link http://book.cakephp.org/2.0/en/models/callback-methods.html#afterfind\n */\n\tpublic function afterFind($results, $primary = false) {\n\t\treturn $results;\n\t}\n\n/**\n * Called before each save operation, after validation. Return a non-true result\n * to halt the save.\n *\n * @param array $options\n * @return boolean True if the operation should continue, false if it should abort\n * @link http://book.cakephp.org/2.0/en/models/callback-methods.html#beforesave\n */\n\tpublic function beforeSave($options = array()) {\n\t\treturn true;\n\t}\n\n/**\n * Called after each successful save operation.\n *\n * @param boolean $created True if this save created a new record\n * @return void\n * @link http://book.cakephp.org/2.0/en/models/callback-methods.html#aftersave\n */\n\tpublic function afterSave($created) {\n\t}\n\n/**\n * Called before every deletion operation.\n *\n * @param boolean $cascade If true records that depend on this record will also be deleted\n * @return boolean True if the operation should continue, false if it should abort\n * @link http://book.cakephp.org/2.0/en/models/callback-methods.html#beforedelete\n */\n\tpublic function beforeDelete($cascade = true) {\n\t\treturn true;\n\t}\n\n/**\n * Called after every deletion operation.\n *\n * @return void\n * @link http://book.cakephp.org/2.0/en/models/callback-methods.html#afterdelete\n */\n\tpublic function afterDelete() {\n\t}\n\n/**\n * Called during validation operations, before validation. Please note that custom\n * validation rules can be defined in $validate.\n *\n * @param array $options Options passed from model::save(), see $options of model::save().\n * @return boolean True if validate operation should continue, false to abort\n * @link http://book.cakephp.org/2.0/en/models/callback-methods.html#beforevalidate\n */\n\tpublic function beforeValidate($options = array()) {\n\t\treturn true;\n\t}\n\n/**\n * Called after data has been checked for errors\n *\n * @return void\n */\n\tpublic function afterValidate() {\n\t}\n\n/**\n * Called when a DataSource-level error occurs.\n *\n * @return void\n * @link http://book.cakephp.org/2.0/en/models/callback-methods.html#onerror\n */\n\tpublic function onError() {\n\t}\n\n/**\n * Clears cache for this model.\n *\n * @param string $type If null this deletes cached views if Cache.check is true\n *     Will be used to allow deleting query cache also\n * @return boolean true on delete\n */\n\tprotected function _clearCache($type = null) {\n\t\tif ($type === null) {\n\t\t\tif (Configure::read('Cache.check') === true) {\n\t\t\t\t$assoc[] = strtolower(Inflector::pluralize($this->alias));\n\t\t\t\t$assoc[] = strtolower(Inflector::underscore(Inflector::pluralize($this->alias)));\n\t\t\t\tforeach ($this->_associations as $key => $association) {\n\t\t\t\t\tforeach ($this->$association as $key => $className) {\n\t\t\t\t\t\t$check = strtolower(Inflector::pluralize($className['className']));\n\t\t\t\t\t\tif (!in_array($check, $assoc)) {\n\t\t\t\t\t\t\t$assoc[] = strtolower(Inflector::pluralize($className['className']));\n\t\t\t\t\t\t\t$assoc[] = strtolower(Inflector::underscore(Inflector::pluralize($className['className'])));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tclearCache($assoc);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\t//Will use for query cache deleting\n\t\t}\n\t}\n\n/**\n * Returns an instance of a model validator for this class\n *\n * @param ModelValidator Model validator instance.\n *  If null a new ModelValidator instance will be made using current model object\n * @return ModelValidator\n */\n\tpublic function validator(ModelValidator $instance = null) {\n\t\tif ($instance) {\n\t\t\t$this->_validator = $instance;\n\t\t} elseif (!$this->_validator) {\n\t\t\t$this->_validator = new ModelValidator($this);\n\t\t}\n\t\treturn $this->_validator;\n\t}\n\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":111559}]],"length":111559}
