{"ts":1377223511236,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"<?php\n/**\n * App class\n *\n * PHP 5\n *\n * CakePHP(tm) : Rapid Development Framework (http://cakephp.org)\n * Copyright (c) Cake Software Foundation, Inc. (http://cakefoundation.org)\n *\n * Licensed under The MIT License\n * For full copyright and license information, please see the LICENSE.txt\n * Redistributions of files must retain the above copyright notice.\n *\n * @copyright     Copyright (c) Cake Software Foundation, Inc. (http://cakefoundation.org)\n * @link          http://cakephp.org CakePHP(tm) Project\n * @package       Cake.Core\n * @since         CakePHP(tm) v 1.2.0.6001\n * @license       http://www.opensource.org/licenses/mit-license.php MIT License\n */\n\nApp::uses('Inflector', 'Utility');\n\n/**\n * App is responsible for path management, class location and class loading.\n *\n * ### Adding paths\n *\n * You can add paths to the search indexes App uses to find classes using `App::build()`. Adding\n * additional controller paths for example would alter where CakePHP looks for controllers.\n * This allows you to split your application up across the filesystem.\n *\n * ### Packages\n *\n * CakePHP is organized around the idea of packages, each class belongs to a package or folder where other\n * classes reside. You can configure each package location in your application using `App::build('APackage/SubPackage', $paths)`\n * to inform the framework where should each class be loaded. Almost every class in the CakePHP framework can be swapped\n * by your own compatible implementation. If you wish to use you own class instead of the classes the framework provides,\n * just add the class to your libs folder mocking the directory location of where CakePHP expects to find it.\n *\n * For instance if you'd like to use your own HttpSocket class, put it under\n *\n *\t\tapp/Network/Http/HttpSocket.php\n *\n * ### Inspecting loaded paths\n *\n * You can inspect the currently loaded paths using `App::path('Controller')` for example to see loaded\n * controller paths.\n *\n * It is also possible to inspect paths for plugin classes, for instance, to see a plugin's helpers you would call\n * `App::path('View/Helper', 'MyPlugin')`\n *\n * ### Locating plugins and themes\n *\n * Plugins and Themes can be located with App as well. Using App::pluginPath('DebugKit') for example, will\n * give you the full path to the DebugKit plugin. App::themePath('purple'), would give the full path to the\n * `purple` theme.\n *\n * ### Inspecting known objects\n *\n * You can find out which objects App knows about using App::objects('Controller') for example to find\n * which application controllers App knows about.\n *\n * @link          http://book.cakephp.org/2.0/en/core-utility-libraries/app.html\n * @package       Cake.Core\n */\nclass App {\n\n/**\n * Append paths\n *\n * @constant APPEND\n */\n\tconst APPEND = 'append';\n\n/**\n * Prepend paths\n *\n * @constant PREPEND\n */\n\tconst PREPEND = 'prepend';\n\n/**\n * Register package\n *\n * @constant REGISTER\n */\n\tconst REGISTER = 'register';\n\n/**\n * Reset paths instead of merging\n *\n * @constant RESET\n */\n\tconst RESET = true;\n\n/**\n * List of object types and their properties\n *\n * @var array\n */\n\tpublic static $types = array(\n\t\t'class' => array('extends' => null, 'core' => true),\n\t\t'file' => array('extends' => null, 'core' => true),\n\t\t'model' => array('extends' => 'AppModel', 'core' => false),\n\t\t'behavior' => array('suffix' => 'Behavior', 'extends' => 'Model/ModelBehavior', 'core' => true),\n\t\t'controller' => array('suffix' => 'Controller', 'extends' => 'AppController', 'core' => true),\n\t\t'component' => array('suffix' => 'Component', 'extends' => null, 'core' => true),\n\t\t'lib' => array('extends' => null, 'core' => true),\n\t\t'view' => array('suffix' => 'View', 'extends' => null, 'core' => true),\n\t\t'helper' => array('suffix' => 'Helper', 'extends' => 'AppHelper', 'core' => true),\n\t\t'vendor' => array('extends' => null, 'core' => true),\n\t\t'shell' => array('suffix' => 'Shell', 'extends' => 'AppShell', 'core' => true),\n\t\t'plugin' => array('extends' => null, 'core' => true)\n\t);\n\n/**\n * Paths to search for files.\n *\n * @var array\n */\n\tpublic static $search = array();\n\n/**\n * Whether or not to return the file that is loaded.\n *\n * @var boolean\n */\n\tpublic static $return = false;\n\n/**\n * Holds key/value pairs of $type => file path.\n *\n * @var array\n */\n\tprotected static $_map = array();\n\n/**\n * Holds and key => value array of object types.\n *\n * @var array\n */\n\tprotected static $_objects = array();\n\n/**\n * Holds the location of each class\n *\n * @var array\n */\n\tprotected static $_classMap = array();\n\n/**\n * Holds the possible paths for each package name\n *\n * @var array\n */\n\tprotected static $_packages = array();\n\n/**\n * Holds the templates for each customizable package path in the application\n *\n * @var array\n */\n\tprotected static $_packageFormat = array();\n\n/**\n * Maps an old style CakePHP class type to the corresponding package\n *\n * @var array\n */\n\tpublic static $legacy = array(\n\t\t'models' => 'Model',\n\t\t'behaviors' => 'Model/Behavior',\n\t\t'datasources' => 'Model/Datasource',\n\t\t'controllers' => 'Controller',\n\t\t'components' => 'Controller/Component',\n\t\t'views' => 'View',\n\t\t'helpers' => 'View/Helper',\n\t\t'shells' => 'Console/Command',\n\t\t'libs' => 'Lib',\n\t\t'vendors' => 'Vendor',\n\t\t'plugins' => 'Plugin',\n\t\t'locales' => 'Locale'\n\t);\n\n/**\n * Indicates whether the class cache should be stored again because of an addition to it\n *\n * @var boolean\n */\n\tprotected static $_cacheChange = false;\n\n/**\n * Indicates whether the object cache should be stored again because of an addition to it\n *\n * @var boolean\n */\n\tprotected static $_objectCacheChange = false;\n\n/**\n * Indicates the the Application is in the bootstrapping process. Used to better cache\n * loaded classes while the cache libraries have not been yet initialized\n *\n * @var boolean\n */\n\tpublic static $bootstrapping = false;\n\n/**\n * Used to read information stored path\n *\n * Usage:\n *\n * `App::path('Model'); will return all paths for models`\n *\n * `App::path('Model/Datasource', 'MyPlugin'); will return the path for datasources under the 'MyPlugin' plugin`\n *\n * @param string $type type of path\n * @param string $plugin name of plugin\n * @return array\n * @link http://book.cakephp.org/2.0/en/core-utility-libraries/app.html#App::path\n */\n\tpublic static function path($type, $plugin = null) {\n\t\tif (!empty(self::$legacy[$type])) {\n\t\t\t$type = self::$legacy[$type];\n\t\t}\n\n\t\tif (!empty($plugin)) {\n\t\t\t$path = array();\n\t\t\t$pluginPath = self::pluginPath($plugin);\n\t\t\t$packageFormat = self::_packageFormat();\n\t\t\tif (!empty($packageFormat[$type])) {\n\t\t\t\tforeach ($packageFormat[$type] as $f) {\n\t\t\t\t\t$path[] = sprintf($f, $pluginPath);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $path;\n\t\t}\n\n\t\tif (!isset(self::$_packages[$type])) {\n\t\t\treturn array();\n\t\t}\n\t\treturn self::$_packages[$type];\n\t}\n\n/**\n * Get all the currently loaded paths from App. Useful for inspecting\n * or storing all paths App knows about. For a paths to a specific package\n * use App::path()\n *\n * @return array An array of packages and their associated paths.\n * @link http://book.cakephp.org/2.0/en/core-utility-libraries/app.html#App::paths\n */\n\tpublic static function paths() {\n\t\treturn self::$_packages;\n\t}\n\n/**\n * Sets up each package location on the file system. You can configure multiple search paths\n * for each package, those will be used to look for files one folder at a time in the specified order\n * All paths should be terminated with a Directory separator\n *\n * Usage:\n *\n * `App::build(array(Model' => array('/a/full/path/to/models/'))); will setup a new search path for the Model package`\n *\n * `App::build(array('Model' => array('/path/to/models/')), App::RESET); will setup the path as the only valid path for searching models`\n *\n * `App::build(array('View/Helper' => array('/path/to/helpers/', '/another/path/'))); will setup multiple search paths for helpers`\n *\n * `App::build(array('Service' => array('%s' . 'Service' . DS)), App::REGISTER); will register new package 'Service'`\n *\n * If reset is set to true, all loaded plugins will be forgotten and they will be needed to be loaded again.\n *\n * @param array $paths associative array with package names as keys and a list of directories for new search paths\n * @param boolean|string $mode App::RESET will set paths, App::APPEND with append paths, App::PREPEND will prepend paths (default)\n * \tApp::REGISTER will register new packages and their paths, %s in path will be replaced by APP path\n * @return void\n * @link http://book.cakephp.org/2.0/en/core-utility-libraries/app.html#App::build\n */\n\tpublic static function build($paths = array(), $mode = App::PREPEND) {\n\t\t//Provides Backwards compatibility for old-style package names\n\t\t$legacyPaths = array();\n\t\tforeach ($paths as $type => $path) {\n\t\t\tif (!empty(self::$legacy[$type])) {\n\t\t\t\t$type = self::$legacy[$type];\n\t\t\t}\n\t\t\t$legacyPaths[$type] = $path;\n\t\t}\n\t\t$paths = $legacyPaths;\n\n\t\tif ($mode === App::RESET) {\n\t\t\tforeach ($paths as $type => $new) {\n\t\t\t\tself::$_packages[$type] = (array)$new;\n\t\t\t\tself::objects($type, null, false);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (empty($paths)) {\n\t\t\tself::$_packageFormat = null;\n\t\t}\n\n\t\t$packageFormat = self::_packageFormat();\n\n\t\tif ($mode === App::REGISTER) {\n\t\t\tforeach ($paths as $package => $formats) {\n\t\t\t\tif (empty($packageFormat[$package])) {\n\t\t\t\t\t$packageFormat[$package] = $formats;\n\t\t\t\t} else {\n\t\t\t\t\t$formats = array_merge($packageFormat[$package], $formats);\n\t\t\t\t\t$packageFormat[$package] = array_values(array_unique($formats));\n\t\t\t\t}\n\t\t\t}\n\t\t\tself::$_packageFormat = $packageFormat;\n\t\t}\n\n\t\t$defaults = array();\n\t\tforeach ($packageFormat as $package => $format) {\n\t\t\tforeach ($format as $f) {\n\t\t\t\t$defaults[$package][] = sprintf($f, APP);\n\t\t\t}\n\t\t}\n\n\t\tif (empty($paths)) {\n\t\t\tself::$_packages = $defaults;\n\t\t\treturn;\n\t\t}\n\n\t\tif ($mode === App::REGISTER) {\n\t\t\t$paths = array();\n\t\t}\n\n\t\tforeach ($defaults as $type => $default) {\n\t\t\tif (!empty(self::$_packages[$type])) {\n\t\t\t\t$path = self::$_packages[$type];\n\t\t\t} else {\n\t\t\t\t$path = $default;\n\t\t\t}\n\n\t\t\tif (!empty($paths[$type])) {\n\t\t\t\t$newPath = (array)$paths[$type];\n\n\t\t\t\tif ($mode === App::PREPEND) {\n\t\t\t\t\t$path = array_merge($newPath, $path);\n\t\t\t\t} else {\n\t\t\t\t\t$path = array_merge($path, $newPath);\n\t\t\t\t}\n\n\t\t\t\t$path = array_values(array_unique($path));\n\t\t\t}\n\n\t\t\tself::$_packages[$type] = $path;\n\t\t}\n\t}\n\n/**\n * Gets the path that a plugin is on. Searches through the defined plugin paths.\n *\n * Usage:\n *\n * `App::pluginPath('MyPlugin'); will return the full path to 'MyPlugin' plugin'`\n *\n * @param string $plugin CamelCased/lower_cased plugin name to find the path of.\n * @return string full path to the plugin.\n * @link http://book.cakephp.org/2.0/en/core-utility-libraries/app.html#App::pluginPath\n */\n\tpublic static function pluginPath($plugin) {\n\t\treturn CakePlugin::path($plugin);\n\t}\n\n/**\n * Finds the path that a theme is on. Searches through the defined theme paths.\n *\n * Usage:\n *\n * `App::themePath('MyTheme'); will return the full path to the 'MyTheme' theme`\n *\n * @param string $theme theme name to find the path of.\n * @return string full path to the theme.\n * @link http://book.cakephp.org/2.0/en/core-utility-libraries/app.html#App::themePath\n */\n\tpublic static function themePath($theme) {\n\t\t$themeDir = 'Themed' . DS . Inflector::camelize($theme);\n\t\tforeach (self::$_packages['View'] as $path) {\n\t\t\tif (is_dir($path . $themeDir)) {\n\t\t\t\treturn $path . $themeDir . DS;\n\t\t\t}\n\t\t}\n\t\treturn self::$_packages['View'][0] . $themeDir . DS;\n\t}\n\n/**\n * Returns the full path to a package inside the CakePHP core\n *\n * Usage:\n *\n * `App::core('Cache/Engine'); will return the full path to the cache engines package`\n *\n * @param string $type\n * @return array full path to package\n * @link http://book.cakephp.org/2.0/en/core-utility-libraries/app.html#App::core\n */\n\tpublic static function core($type) {\n\t\treturn array(CAKE . str_replace('/', DS, $type) . DS);\n\t}\n\n/**\n * Returns an array of objects of the given type.\n *\n * Example usage:\n *\n * `App::objects('plugin');` returns `array('DebugKit', 'Blog', 'User');`\n *\n * `App::objects('Controller');` returns `array('PagesController', 'BlogController');`\n *\n * You can also search only within a plugin's objects by using the plugin dot\n * syntax.\n *\n * `App::objects('MyPlugin.Model');` returns `array('MyPluginPost', 'MyPluginComment');`\n *\n * When scanning directories, files and directories beginning with `.` will be excluded as these\n * are commonly used by version control systems.\n *\n * @param string $type Type of object, i.e. 'Model', 'Controller', 'View/Helper', 'file', 'class' or 'plugin'\n * @param string|array $path Optional Scan only the path given. If null, paths for the chosen type will be used.\n * @param boolean $cache Set to false to rescan objects of the chosen type. Defaults to true.\n * @return mixed Either false on incorrect / miss. Or an array of found objects.\n * @link http://book.cakephp.org/2.0/en/core-utility-libraries/app.html#App::objects\n */\n\tpublic static function objects($type, $path = null, $cache = true) {\n\t\tif (empty(self::$_objects) && $cache === true) {\n\t\t\tself::$_objects = (array)Cache::read('object_map', '_cake_core_');\n\t\t}\n\n\t\t$extension = '/\\.php$/';\n\t\t$includeDirectories = false;\n\t\t$name = $type;\n\n\t\tif ($type === 'plugin') {\n\t\t\t$type = 'plugins';\n\t\t}\n\n\t\tif ($type === 'plugins') {\n\t\t\t$extension = '/.*/';\n\t\t\t$includeDirectories = true;\n\t\t}\n\n\t\tlist($plugin, $type) = pluginSplit($type);\n\n\t\tif (isset(self::$legacy[$type . 's'])) {\n\t\t\t$type = self::$legacy[$type . 's'];\n\t\t}\n\n\t\tif ($type === 'file' && !$path) {\n\t\t\treturn false;\n\t\t} elseif ($type === 'file') {\n\t\t\t$extension = '/\\.php$/';\n\t\t\t$name = $type . str_replace(DS, '', $path);\n\t\t}\n\n\t\t$cacheLocation = empty($plugin) ? 'app' : $plugin;\n\n\t\tif ($cache !== true || !isset(self::$_objects[$cacheLocation][$name])) {\n\t\t\t$objects = array();\n\n\t\t\tif (empty($path)) {\n\t\t\t\t$path = self::path($type, $plugin);\n\t\t\t}\n\n\t\t\tforeach ((array)$path as $dir) {\n\t\t\t\tif ($dir != APP && is_dir($dir)) {\n\t\t\t\t\t$files = new RegexIterator(new DirectoryIterator($dir), $extension);\n\t\t\t\t\tforeach ($files as $file) {\n\t\t\t\t\t\t$fileName = basename($file);\n\t\t\t\t\t\tif (!$file->isDot() && $fileName[0] !== '.') {\n\t\t\t\t\t\t\t$isDir = $file->isDir();\n\t\t\t\t\t\t\tif ($isDir && $includeDirectories) {\n\t\t\t\t\t\t\t\t$objects[] = $fileName;\n\t\t\t\t\t\t\t} elseif (!$includeDirectories && !$isDir) {\n\t\t\t\t\t\t\t\t$objects[] = substr($fileName, 0, -4);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ($type !== 'file') {\n\t\t\t\tforeach ($objects as $key => $value) {\n\t\t\t\t\t$objects[$key] = Inflector::camelize($value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsort($objects);\n\t\t\tif ($plugin) {\n\t\t\t\treturn $objects;\n\t\t\t}\n\n\t\t\tself::$_objects[$cacheLocation][$name] = $objects;\n\t\t\tif ($cache) {\n\t\t\t\tself::$_objectCacheChange = true;\n\t\t\t}\n\t\t}\n\n\t\treturn self::$_objects[$cacheLocation][$name];\n\t}\n\n/**\n * Declares a package for a class. This package location will be used\n * by the automatic class loader if the class is tried to be used\n *\n * Usage:\n *\n * `App::uses('MyCustomController', 'Controller');` will setup the class to be found under Controller package\n *\n * `App::uses('MyHelper', 'MyPlugin.View/Helper');` will setup the helper class to be found in plugin's helper package\n *\n * @param string $className the name of the class to configure package for\n * @param string $location the package name\n * @return void\n * @link http://book.cakephp.org/2.0/en/core-utility-libraries/app.html#App::uses\n */\n\tpublic static function uses($className, $location) {\n\t\tself::$_classMap[$className] = $location;\n\t}\n\n/**\n * Method to handle the automatic class loading. It will look for each class' package\n * defined using App::uses() and with this information it will resolve the package name to a full path\n * to load the class from. File name for each class should follow the class name. For instance,\n * if a class is name `MyCustomClass` the file name should be `MyCustomClass.php`\n *\n * @param string $className the name of the class to load\n * @return boolean\n */\n\tpublic static function load($className) {\n\t\tif (!isset(self::$_classMap[$className])) {\n\t\t\treturn false;\n\t\t}\n\t\tif (strpos($className, '..') !== false) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$parts = explode('.', self::$_classMap[$className], 2);\n\t\tlist($plugin, $package) = count($parts) > 1 ? $parts : array(null, current($parts));\n\n\t\t$file = self::_mapped($className, $plugin);\n\t\tif ($file) {\n\t\t\treturn include $file;\n\t\t}\n\t\t$paths = self::path($package, $plugin);\n\n\t\tif (empty($plugin)) {\n\t\t\t$appLibs = empty(self::$_packages['Lib']) ? APPLIBS : current(self::$_packages['Lib']);\n\t\t\t$paths[] = $appLibs . $package . DS;\n\t\t\t$paths[] = APP . $package . DS;\n\t\t\t$paths[] = CAKE . $package . DS;\n\t\t} else {\n\t\t\t$pluginPath = self::pluginPath($plugin);\n\t\t\t$paths[] = $pluginPath . 'Lib' . DS . $package . DS;\n\t\t\t$paths[] = $pluginPath . $package . DS;\n\t\t}\n\n\t\t$normalizedClassName = str_replace('\\\\', DS, $className);\n\t\tforeach ($paths as $path) {\n\t\t\t$file = $path . $normalizedClassName . '.php';\n\t\t\tif (file_exists($file)) {\n\t\t\t\tself::_map($file, $className, $plugin);\n\t\t\t\treturn include $file;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n/**\n * Returns the package name where a class was defined to be located at\n *\n * @param string $className name of the class to obtain the package name from\n * @return string package name or null if not declared\n * @link http://book.cakephp.org/2.0/en/core-utility-libraries/app.html#App::location\n */\n\tpublic static function location($className) {\n\t\tif (!empty(self::$_classMap[$className])) {\n\t\t\treturn self::$_classMap[$className];\n\t\t}\n\t\treturn null;\n\t}\n\n/**\n * Finds classes based on $name or specific file(s) to search. Calling App::import() will\n * not construct any classes contained in the files. It will only find and require() the file.\n *\n * @link          http://book.cakephp.org/2.0/en/core-utility-libraries/app.html#including-files-with-app-import\n * @param string|array $type The type of Class if passed as a string, or all params can be passed as\n *                    an single array to $type,\n * @param string $name Name of the Class or a unique name for the file\n * @param boolean|array $parent boolean true if Class Parent should be searched, accepts key => value\n *              array('parent' => $parent, 'file' => $file, 'search' => $search, 'ext' => '$ext');\n *              $ext allows setting the extension of the file name\n *              based on Inflector::underscore($name) . \".$ext\";\n * @param array $search paths to search for files, array('path 1', 'path 2', 'path 3');\n * @param string $file full name of the file to search for including extension\n * @param boolean $return Return the loaded file, the file must have a return\n *                         statement in it to work: return $variable;\n * @return boolean true if Class is already in memory or if file is found and loaded, false if not\n */\n\tpublic static function import($type = null, $name = null, $parent = true, $search = array(), $file = null, $return = false) {\n\t\t$ext = null;\n\n\t\tif (is_array($type)) {\n\t\t\textract($type, EXTR_OVERWRITE);\n\t\t}\n\n\t\tif (is_array($parent)) {\n\t\t\textract($parent, EXTR_OVERWRITE);\n\t\t}\n\n\t\tif (!$name && !$file) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (is_array($name)) {\n\t\t\tforeach ($name as $class) {\n\t\t\t\tif (!App::import(compact('type', 'parent', 'search', 'file', 'return') + array('name' => $class))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t$originalType = strtolower($type);\n\t\t$specialPackage = in_array($originalType, array('file', 'vendor'));\n\t\tif (!$specialPackage && isset(self::$legacy[$originalType . 's'])) {\n\t\t\t$type = self::$legacy[$originalType . 's'];\n\t\t}\n\t\tlist($plugin, $name) = pluginSplit($name);\n\t\tif (!empty($plugin)) {\n\t\t\tif (!CakePlugin::loaded($plugin)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (!$specialPackage) {\n\t\t\treturn self::_loadClass($name, $plugin, $type, $originalType, $parent);\n\t\t}\n\n\t\tif ($originalType === 'file' && !empty($file)) {\n\t\t\treturn self::_loadFile($name, $plugin, $search, $file, $return);\n\t\t}\n\n\t\tif ($originalType === 'vendor') {\n\t\t\treturn self::_loadVendor($name, $plugin, $file, $ext);\n\t\t}\n\n\t\treturn false;\n\t}\n\n/**\n * Helper function to include classes\n * This is a compatibility wrapper around using App::uses() and automatic class loading\n *\n * @param string $name unique name of the file for identifying it inside the application\n * @param string $plugin camel cased plugin name if any\n * @param string $type name of the packed where the class is located\n * @param string $originalType type name as supplied initially by the user\n * @param boolean $parent whether to load the class parent or not\n * @return boolean true indicating the successful load and existence of the class\n */\n\tprotected static function _loadClass($name, $plugin, $type, $originalType, $parent) {\n\t\tif ($type === 'Console/Command' && $name === 'Shell') {\n\t\t\t$type = 'Console';\n\t\t} elseif (isset(self::$types[$originalType]['suffix'])) {\n\t\t\t$suffix = self::$types[$originalType]['suffix'];\n\t\t\t$name .= ($suffix == $name) ? '' : $suffix;\n\t\t}\n\t\tif ($parent && isset(self::$types[$originalType]['extends'])) {\n\t\t\t$extends = self::$types[$originalType]['extends'];\n\t\t\t$extendType = $type;\n\t\t\tif (strpos($extends, '/') !== false) {\n\t\t\t\t$parts = explode('/', $extends);\n\t\t\t\t$extends = array_pop($parts);\n\t\t\t\t$extendType = implode('/', $parts);\n\t\t\t}\n\t\t\tApp::uses($extends, $extendType);\n\t\t\tif ($plugin && in_array($originalType, array('controller', 'model'))) {\n\t\t\t\tApp::uses($plugin . $extends, $plugin . '.' . $type);\n\t\t\t}\n\t\t}\n\t\tif ($plugin) {\n\t\t\t$plugin .= '.';\n\t\t}\n\t\t$name = Inflector::camelize($name);\n\t\tApp::uses($name, $plugin . $type);\n\t\treturn class_exists($name);\n\t}\n\n/**\n * Helper function to include single files\n *\n * @param string $name unique name of the file for identifying it inside the application\n * @param string $plugin camel cased plugin name if any\n * @param array $search list of paths to search the file into\n * @param string $file filename if known, the $name param will be used otherwise\n * @param boolean $return whether this function should return the contents of the file after being parsed by php or just a success notice\n * @return mixed if $return contents of the file after php parses it, boolean indicating success otherwise\n */\n\tprotected static function _loadFile($name, $plugin, $search, $file, $return) {\n\t\t$mapped = self::_mapped($name, $plugin);\n\t\tif ($mapped) {\n\t\t\t$file = $mapped;\n\t\t} elseif (!empty($search)) {\n\t\t\tforeach ($search as $path) {\n\t\t\t\t$found = false;\n\t\t\t\tif (file_exists($path . $file)) {\n\t\t\t\t\t$file = $path . $file;\n\t\t\t\t\t$found = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (empty($found)) {\n\t\t\t\t\t$file = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!empty($file) && file_exists($file)) {\n\t\t\tself::_map($file, $name, $plugin);\n\t\t\t$returnValue = include $file;\n\t\t\tif ($return) {\n\t\t\t\treturn $returnValue;\n\t\t\t}\n\t\t\treturn (bool)$returnValue;\n\t\t}\n\t\treturn false;\n\t}\n\n/**\n * Helper function to load files from vendors folders\n *\n * @param string $name unique name of the file for identifying it inside the application\n * @param string $plugin camel cased plugin name if any\n * @param string $file file name if known\n * @param string $ext file extension if known\n * @return boolean true if the file was loaded successfully, false otherwise\n */\n\tprotected static function _loadVendor($name, $plugin, $file, $ext) {\n\t\tif ($mapped = self::_mapped($name, $plugin)) {\n\t\t\treturn (bool)include_once $mapped;\n\t\t}\n\t\t$fileTries = array();\n\t\t$paths = ($plugin) ? App::path('vendors', $plugin) : App::path('vendors');\n\t\tif (empty($ext)) {\n\t\t\t$ext = 'php';\n\t\t}\n\t\tif (empty($file)) {\n\t\t\t$fileTries[] = $name . '.' . $ext;\n\t\t\t$fileTries[] = Inflector::underscore($name) . '.' . $ext;\n\t\t} else {\n\t\t\t$fileTries[] = $file;\n\t\t}\n\n\t\tforeach ($fileTries as $file) {\n\t\t\tforeach ($paths as $path) {\n\t\t\t\tif (file_exists($path . $file)) {\n\t\t\t\t\tself::_map($path . $file, $name, $plugin);\n\t\t\t\t\treturn (bool)include $path . $file;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n/**\n * Initializes the cache for App, registers a shutdown function.\n *\n * @return void\n */\n\tpublic static function init() {\n\t\tself::$_map += (array)Cache::read('file_map', '_cake_core_');\n\t\tregister_shutdown_function(array('App', 'shutdown'));\n\t}\n\n/**\n * Maps the $name to the $file.\n *\n * @param string $file full path to file\n * @param string $name unique name for this map\n * @param string $plugin camelized if object is from a plugin, the name of the plugin\n * @return void\n */\n\tprotected static function _map($file, $name, $plugin = null) {\n\t\t$key = $name;\n\t\tif ($plugin) {\n\t\t\t$key = 'plugin.' . $name;\n\t\t}\n\t\tif ($plugin && empty(self::$_map[$name])) {\n\t\t\tself::$_map[$key] = $file;\n\t\t}\n\t\tif (!$plugin && empty(self::$_map['plugin.' . $name])) {\n\t\t\tself::$_map[$key] = $file;\n\t\t}\n\t\tif (!self::$bootstrapping) {\n\t\t\tself::$_cacheChange = true;\n\t\t}\n\t}\n\n/**\n * Returns a file's complete path.\n *\n * @param string $name unique name\n * @param string $plugin camelized if object is from a plugin, the name of the plugin\n * @return mixed file path if found, false otherwise\n */\n\tprotected static function _mapped($name, $plugin = null) {\n\t\t$key = $name;\n\t\tif ($plugin) {\n\t\t\t$key = 'plugin.' . $name;\n\t\t}\n\t\treturn isset(self::$_map[$key]) ? self::$_map[$key] : false;\n\t}\n\n/**\n * Sets then returns the templates for each customizable package path\n *\n * @return array templates for each customizable package path\n */\n\tprotected static function _packageFormat() {\n\t\tif (empty(self::$_packageFormat)) {\n\t\t\tself::$_packageFormat = array(\n\t\t\t\t'Model' => array(\n\t\t\t\t\t'%s' . 'Model' . DS\n\t\t\t\t),\n\t\t\t\t'Model/Behavior' => array(\n\t\t\t\t\t'%s' . 'Model' . DS . 'Behavior' . DS\n\t\t\t\t),\n\t\t\t\t'Model/Datasource' => array(\n\t\t\t\t\t'%s' . 'Model' . DS . 'Datasource' . DS\n\t\t\t\t),\n\t\t\t\t'Model/Datasource/Database' => array(\n\t\t\t\t\t'%s' . 'Model' . DS . 'Datasource' . DS . 'Database' . DS\n\t\t\t\t),\n\t\t\t\t'Model/Datasource/Session' => array(\n\t\t\t\t\t'%s' . 'Model' . DS . 'Datasource' . DS . 'Session' . DS\n\t\t\t\t),\n\t\t\t\t'Controller' => array(\n\t\t\t\t\t'%s' . 'Controller' . DS\n\t\t\t\t),\n\t\t\t\t'Controller/Component' => array(\n\t\t\t\t\t'%s' . 'Controller' . DS . 'Component' . DS\n\t\t\t\t),\n\t\t\t\t'Controller/Component/Auth' => array(\n\t\t\t\t\t'%s' . 'Controller' . DS . 'Component' . DS . 'Auth' . DS\n\t\t\t\t),\n\t\t\t\t'Controller/Component/Acl' => array(\n\t\t\t\t\t'%s' . 'Controller' . DS . 'Component' . DS . 'Acl' . DS\n\t\t\t\t),\n\t\t\t\t'View' => array(\n\t\t\t\t\t'%s' . 'View' . DS\n\t\t\t\t),\n\t\t\t\t'View/Helper' => array(\n\t\t\t\t\t'%s' . 'View' . DS . 'Helper' . DS\n\t\t\t\t),\n\t\t\t\t'Console' => array(\n\t\t\t\t\t'%s' . 'Console' . DS\n\t\t\t\t),\n\t\t\t\t'Console/Command' => array(\n\t\t\t\t\t'%s' . 'Console' . DS . 'Command' . DS\n\t\t\t\t),\n\t\t\t\t'Console/Command/Task' => array(\n\t\t\t\t\t'%s' . 'Console' . DS . 'Command' . DS . 'Task' . DS\n\t\t\t\t),\n\t\t\t\t'Lib' => array(\n\t\t\t\t\t'%s' . 'Lib' . DS\n\t\t\t\t),\n\t\t\t\t'Locale' => array(\n\t\t\t\t\t'%s' . 'Locale' . DS\n\t\t\t\t),\n\t\t\t\t'Vendor' => array(\n\t\t\t\t\t'%s' . 'Vendor' . DS,\n\t\t\t\t\tdirname(dirname(CAKE)) . DS . 'vendors' . DS,\n\t\t\t\t),\n\t\t\t\t'Plugin' => array(\n\t\t\t\t\tAPP . 'Plugin' . DS,\n\t\t\t\t\tdirname(dirname(CAKE)) . DS . 'plugins' . DS\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\treturn self::$_packageFormat;\n\t}\n\n/**\n * Object destructor.\n *\n * Writes cache file if changes have been made to the $_map. Also, check if a fatal\n * error happened and call the handler.\n *\n * @return void\n */\n\tpublic static function shutdown() {\n\t\tif (self::$_cacheChange) {\n\t\t\tCache::write('file_map', array_filter(self::$_map), '_cake_core_');\n\t\t}\n\t\tif (self::$_objectCacheChange) {\n\t\t\tCache::write('object_map', self::$_objects, '_cake_core_');\n\t\t}\n\t\tself::_checkFatalError();\n\t}\n\n/**\n * Check if a fatal error happened and trigger the configured handler if configured\n *\n * @return void\n */\n\tprotected static function _checkFatalError() {\n\t\t$lastError = error_get_last();\n\t\tif (!is_array($lastError)) {\n\t\t\treturn;\n\t\t}\n\n\t\tlist(, $log) = ErrorHandler::mapErrorCode($lastError['type']);\n\t\tif ($log !== LOG_ERR) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (PHP_SAPI === 'cli') {\n\t\t\t$errorHandler = Configure::read('Error.consoleHandler');\n\t\t} else {\n\t\t\t$errorHandler = Configure::read('Error.handler');\n\t\t}\n\t\tif (!is_callable($errorHandler)) {\n\t\t\treturn;\n\t\t}\n\t\tcall_user_func($errorHandler, $lastError['type'], $lastError['message'], $lastError['file'], $lastError['line'], array());\n\t}\n\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":28014}]],"length":28014}
