{"ts":1377223661986,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"<?php\n/**\n * CakePlugin class\n *\n * PHP 5\n *\n * CakePHP(tm) : Rapid Development Framework (http://cakephp.org)\n * Copyright (c) Cake Software Foundation, Inc. (http://cakefoundation.org)\n *\n * Licensed under The MIT License\n * For full copyright and license information, please see the LICENSE.txt\n * Redistributions of files must retain the above copyright notice.\n *\n * @copyright     Copyright (c) Cake Software Foundation, Inc. (http://cakefoundation.org)\n * @link          http://cakephp.org CakePHP(tm) Project\n * @package       Cake.Core\n * @since         CakePHP(tm) v 2.0.0\n * @license       http://www.opensource.org/licenses/mit-license.php MIT License\n */\n\n/**\n * CakePlugin is responsible for loading and unloading plugins. It also can\n * retrieve plugin paths and load their bootstrap and routes files.\n *\n * @package       Cake.Core\n * @link http://book.cakephp.org/2.0/en/plugins.html\n */\nclass CakePlugin {\n\n/**\n * Holds a list of all loaded plugins and their configuration\n *\n * @var array\n */\n\tprotected static $_plugins = array();\n\n/**\n * Loads a plugin and optionally loads bootstrapping, routing files or loads a initialization function\n *\n * Examples:\n *\n * \t`CakePlugin::load('DebugKit')` will load the DebugKit plugin and will not load any bootstrap nor route files\n *\t`CakePlugin::load('DebugKit', array('bootstrap' => true, 'routes' => true))` will load the bootstrap.php and routes.php files\n * \t`CakePlugin::load('DebugKit', array('bootstrap' => false, 'routes' => true))` will load routes.php file but not bootstrap.php\n * \t`CakePlugin::load('DebugKit', array('bootstrap' => array('config1', 'config2')))` will load config1.php and config2.php files\n *\t`CakePlugin::load('DebugKit', array('bootstrap' => 'aCallableMethod'))` will run the aCallableMethod function to initialize it\n *\n * Bootstrap initialization functions can be expressed as a PHP callback type, including closures. Callbacks will receive two\n * parameters (plugin name, plugin configuration)\n *\n * It is also possible to load multiple plugins at once. Examples:\n *\n * `CakePlugin::load(array('DebugKit', 'ApiGenerator'))` will load the DebugKit and ApiGenerator plugins\n * `CakePlugin::load(array('DebugKit', 'ApiGenerator'), array('bootstrap' => true))` will load bootstrap file for both plugins\n *\n * {{{\n * \tCakePlugin::load(array(\n * \t\t'DebugKit' => array('routes' => true),\n * \t\t'ApiGenerator'\n * \t\t), array('bootstrap' => true))\n * }}}\n *\n * Will only load the bootstrap for ApiGenerator and only the routes for DebugKit\n *\n * @param string|array $plugin name of the plugin to be loaded in CamelCase format or array or plugins to load\n * @param array $config configuration options for the plugin\n * @throws MissingPluginException if the folder for the plugin to be loaded is not found\n * @return void\n */\n\tpublic static function load($plugin, $config = array()) {\n\t\tif (is_array($plugin)) {\n\t\t\tforeach ($plugin as $name => $conf) {\n\t\t\t\tlist($name, $conf) = (is_numeric($name)) ? array($conf, $config) : array($name, $conf);\n\t\t\t\tself::load($name, $conf);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t$config += array('bootstrap' => false, 'routes' => false, 'ignoreMissing' => false);\n\t\tif (empty($config['path'])) {\n\t\t\tforeach (App::path('plugins') as $path) {\n\t\t\t\tif (is_dir($path . $plugin)) {\n\t\t\t\t\tself::$_plugins[$plugin] = $config + array('path' => $path . $plugin . DS);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t//Backwards compatibility to make easier to migrate to 2.0\n\t\t\t\t$underscored = Inflector::underscore($plugin);\n\t\t\t\tif (is_dir($path . $underscored)) {\n\t\t\t\t\tself::$_plugins[$plugin] = $config + array('path' => $path . $underscored . DS);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tself::$_plugins[$plugin] = $config;\n\t\t}\n\n\t\tif (empty(self::$_plugins[$plugin]['path'])) {\n\t\t\tthrow new MissingPluginException(array('plugin' => $plugin));\n\t\t}\n\t\tif (!empty(self::$_plugins[$plugin]['bootstrap'])) {\n\t\t\tself::bootstrap($plugin);\n\t\t}\n\t}\n\n/**\n * Will load all the plugins located in the configured plugins folders\n * If passed an options array, it will be used as a common default for all plugins to be loaded\n * It is possible to set specific defaults for each plugins in the options array. Examples:\n *\n * {{{\n * \tCakePlugin::loadAll(array(\n *\t\tarray('bootstrap' => true),\n * \t\t'DebugKit' => array('routes' => true),\n * \t))\n * }}}\n *\n * The above example will load the bootstrap file for all plugins, but for DebugKit it will only load the routes file\n * and will not look for any bootstrap script.\n *\n * @param array $options\n * @return void\n */\n\tpublic static function loadAll($options = array()) {\n\t\t$plugins = App::objects('plugins');\n\t\tforeach ($plugins as $p) {\n\t\t\t$opts = isset($options[$p]) ? $options[$p] : null;\n\t\t\tif ($opts === null && isset($options[0])) {\n\t\t\t\t$opts = $options[0];\n\t\t\t}\n\t\t\tself::load($p, (array)$opts);\n\t\t}\n\t}\n\n/**\n * Returns the filesystem path for a plugin\n *\n * @param string $plugin name of the plugin in CamelCase format\n * @return string path to the plugin folder\n * @throws MissingPluginException if the folder for plugin was not found or plugin has not been loaded\n */\n\tpublic static function path($plugin) {\n\t\tif (empty(self::$_plugins[$plugin])) {\n\t\t\tthrow new MissingPluginException(array('plugin' => $plugin));\n\t\t}\n\t\treturn self::$_plugins[$plugin]['path'];\n\t}\n\n/**\n * Loads the bootstrapping files for a plugin, or calls the initialization setup in the configuration\n *\n * @param string $plugin name of the plugin\n * @return mixed\n * @see CakePlugin::load() for examples of bootstrap configuration\n */\n\tpublic static function bootstrap($plugin) {\n\t\t$config = self::$_plugins[$plugin];\n\t\tif ($config['bootstrap'] === false) {\n\t\t\treturn false;\n\t\t}\n\t\tif (is_callable($config['bootstrap'])) {\n\t\t\treturn call_user_func_array($config['bootstrap'], array($plugin, $config));\n\t\t}\n\n\t\t$path = self::path($plugin);\n\t\tif ($config['bootstrap'] === true) {\n\t\t\treturn self::_includeFile(\n\t\t\t\t$path . 'Config' . DS . 'bootstrap.php',\n\t\t\t\t$config['ignoreMissing']\n\t\t\t);\n\t\t}\n\n\t\t$bootstrap = (array)$config['bootstrap'];\n\t\tforeach ($bootstrap as $file) {\n\t\t\tself::_includeFile(\n\t\t\t\t$path . 'Config' . DS . $file . '.php',\n\t\t\t\t$config['ignoreMissing']\n\t\t\t);\n\t\t}\n\n\t\treturn true;\n\t}\n\n/**\n * Loads the routes file for a plugin, or all plugins configured to load their respective routes file\n *\n * @param string $plugin name of the plugin, if null will operate on all plugins having enabled the\n * loading of routes files\n * @return boolean\n */\n\tpublic static function routes($plugin = null) {\n\t\tif ($plugin === null) {\n\t\t\tforeach (self::loaded() as $p) {\n\t\t\t\tself::routes($p);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t$config = self::$_plugins[$plugin];\n\t\tif ($config['routes'] === false) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (bool)self::_includeFile(\n\t\t\tself::path($plugin) . 'Config' . DS . 'routes.php',\n\t\t\t$config['ignoreMissing']\n\t\t);\n\t}\n\n/**\n * Returns true if the plugin $plugin is already loaded\n * If plugin is null, it will return a list of all loaded plugins\n *\n * @param string $plugin\n * @return mixed boolean true if $plugin is already loaded.\n * If $plugin is null, returns a list of plugins that have been loaded\n */\n\tpublic static function loaded($plugin = null) {\n\t\tif ($plugin) {\n\t\t\treturn isset(self::$_plugins[$plugin]);\n\t\t}\n\t\t$return = array_keys(self::$_plugins);\n\t\tsort($return);\n\t\treturn $return;\n\t}\n\n/**\n * Forgets a loaded plugin or all of them if first parameter is null\n *\n * @param string $plugin name of the plugin to forget\n * @return void\n */\n\tpublic static function unload($plugin = null) {\n\t\tif (is_null($plugin)) {\n\t\t\tself::$_plugins = array();\n\t\t} else {\n\t\t\tunset(self::$_plugins[$plugin]);\n\t\t}\n\t}\n\n/**\n * Include file, ignoring include error if needed if file is missing\n *\n * @param string $file File to include\n * @param boolean $ignoreMissing Whether to ignore include error for missing files\n * @return mixed\n */\n\tprotected static function _includeFile($file, $ignoreMissing = false) {\n\t\tif ($ignoreMissing && !is_file($file)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn include $file;\n\t}\n\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":7989}]],"length":7989}
